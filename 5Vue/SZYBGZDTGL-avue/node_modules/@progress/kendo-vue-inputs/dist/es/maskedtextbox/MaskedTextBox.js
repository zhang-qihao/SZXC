// @ts-ignore
import * as Vue from 'vue';
var allVue = Vue;
var gh = allVue.h;
var ref = allVue.ref;
import { MaskingService } from './masking.service';
import { defaultRules, maskingChanged, returnFalse } from './utils';
import { guid, classNames, getTabIndex } from '@progress/kendo-vue-common';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from '../package-metadata';
/**
 * Represents the default `MaskedTextBox` component.
 */

var MaskedTextBox = {
  model: {
    event: 'changemodel'
  },
  props: {
    modelValue: String,
    modelRawValue: String,
    value: String,
    defaultValue: String,
    placeholder: String,
    title: String,
    dir: String,
    id: String,
    ariaLabelledBy: String,
    ariaDescribedBy: String,
    tabIndex: Number,
    accessKey: String,
    disabled: Boolean,
    readonly: Boolean,
    prompt: {
      type: String,
      default: '_'
    },
    promptPlaceholder: {
      type: String,
      default: ' '
    },
    includeLiterals: {
      type: Boolean,
      default: false
    },
    maskValidation: {
      type: Boolean,
      default: true
    },
    mask: String,
    rules: {
      type: Object,
      default: function _default() {
        return defaultRules;
      }
    },
    selection: Object,
    name: String,
    label: String,
    validationMessage: String,
    required: {
      type: Boolean,
      default: false
    },
    valid: {
      type: Boolean,
      default: undefined
    },
    validityStyles: {
      type: Boolean,
      default: true
    }
  },
  data: function data() {
    return {
      currentValue: undefined,
      currentFocused: false,
      inputValue: undefined,
      currentSelection: [null, null]
    };
  },
  created: function created() {
    validatePackage(packageMetadata);
    this.hasMounted = false;
    this.valueDuringOnChange = undefined;
    this.inputId = "k-" + guid();
    this.service = new MaskingService();
    this.isPasted = false;
  },
  // @ts-ignore
  setup: !gh ? undefined : function () {
    var v3 = !!gh;
    var inputRef = ref(null);
    return {
      v3: v3,
      inputRef: inputRef
    };
  },
  mounted: function mounted() {
    this.hasMounted = true; // @ts-ignore

    this.element = this.input = this.v3 ? this.inputRef : this.$refs.input;
    this.updateService();
    this.setValidity();
  },
  watch: {
    currentFocused: function currentFocused(_, oldValue) {
      this.prevCurrentFocused = oldValue;
    },
    selection: function selection(_, oldValue) {
      this.prevSelection = oldValue;
    },
    includeLiterals: function includeLiterals(_, oldValue) {
      this.prevIncludeLiterals = oldValue;
    },
    mask: function mask(_, oldValue) {
      this.prevMask = oldValue;
    },
    prompt: function prompt(_, oldValue) {
      this.prevPrompt = oldValue;
    },
    promptPlaceholder: function promptPlaceholder(_, oldValue) {
      this.prevPromptPlaceholder = oldValue;
    },
    rules: function rules(_, oldValue) {
      this.prevRules = oldValue;
    }
  },
  updated: function updated() {
    if (this.element && this.currentFocused) {
      // && this.prevCurrentFocused
      var _a = this.currentSelection,
          start = _a[0],
          end = _a[1];
      var prevSelection = this.prevSelection;
      var nextSelection = this.$props.selection;

      if (!prevSelection && nextSelection || prevSelection && nextSelection && (prevSelection.start !== nextSelection.start || prevSelection.end !== nextSelection.end)) {
        start = nextSelection.start;
        end = nextSelection.end;
      }

      if (start !== null && end !== null) {
        this.element.setSelectionRange(start, end);
      }
    }

    var prevProps = {
      includeLiterals: this.prevIncludeLiterals,
      mask: this.prevMask,
      prompt: this.prevPrompt,
      promptPlaceholder: this.prevPromptPlaceholder,
      rules: this.prevRules
    };

    if (maskingChanged(prevProps, this.$props)) {
      this.updateService();
    }

    this.setValidity();
  },
  computed: {
    computedRules: {
      get: function get() {
        return Object.assign({}, defaultRules, this.$props.rules);
      }
    },
    spanClassNames: {
      get: function get() {
        var isValid = !this.hasMounted || !this.$props.validityStyles || this.validity().valid;
        return {
          'k-textbox-container': true,
          'k-state-focused': this.currentFocused,
          'k-state-empty': !this.computedValue(),
          'k-state-invalid': !isValid && isValid !== undefined,
          'k-rtl': this.$props.dir === 'rtl'
        };
      }
    }
  },
  methods: {
    focus: function focus() {
      if (this.input) {
        this.input.focus();
      }
    },
    computedValue: function computedValue() {
      var value;

      if (this.valueDuringOnChange !== undefined) {
        value = this.valueDuringOnChange;
      } else if (this.$props.value !== undefined) {
        value = this.$props.value;
      } else if (this.$props.modelValue !== undefined) {
        value = this.$props.modelValue;
      } else if (this.currentValue !== undefined) {
        value = this.currentValue;
      } else if (this.$props.defaultValue !== undefined) {
        value = this.$props.defaultValue;
      }

      return value || '';
    },
    rawValue: function rawValue() {
      return this.service.rawValue(this.computedValue());
    },
    validity: function validity() {
      var maskedValue = this.computedValue();
      var value = this.service.validationValue(maskedValue);
      var customError = this.$props.validationMessage !== undefined;
      var valid = this.$props.valid !== undefined ? this.$props.valid : (!this.$props.required || !!value) && (!this.$props.maskValidation || !this.$props.prompt || maskedValue.indexOf(this.$props.prompt) === -1);
      return {
        customError: customError,
        valid: valid,
        valueMissing: !value
      };
    },
    pasteHandler: function pasteHandler(event) {
      var _a = event.target,
          selectionStart = _a.selectionStart,
          selectionEnd = _a.selectionEnd;

      if (selectionEnd === selectionStart) {
        return;
      }

      this.isPasted = true;
      this.currentSelection = [selectionStart || 0, selectionEnd || 0];
    },
    onChangeHandler: function onChangeHandler(event) {
      var input = event.currentTarget;
      var value = this.inputValue = input.value;
      var start = this.currentSelection[0] || 0;
      var end = this.currentSelection[1] || 0;

      if (!this.$props.mask) {
        this.isPasted = false;
        this.currentSelection = [null, null];
        this.triggerOnChange(value, event);
        return;
      }

      var maskedValue = this.computedValue();
      var result;

      if (this.isPasted) {
        this.isPasted = false;
        var rightPart = maskedValue.length - end;
        var to = value.length - rightPart;
        result = this.service.maskInRange(value.slice(start, to), maskedValue, start, end);
      } else {
        result = this.service.maskInput(value, maskedValue, input.selectionStart || 0);
      }

      this.currentSelection = [result.selection, result.selection];
      this.triggerOnChange(result.value, event);
      this.inputValue = undefined;
    },
    focusHandler: function focusHandler(event) {
      if (!this.currentFocused) {
        this.currentFocused = true;
        this.$emit('focus', {
          target: this,
          event: event
        });
      }
    },
    blurHandler: function blurHandler(event) {
      if (this.currentFocused) {
        this.currentFocused = false;
        this.$emit('blur', {
          target: this,
          event: event
        });
      }
    },
    triggerOnChange: function triggerOnChange(maskedValue, event) {
      this.currentValue = maskedValue;
      this.valueDuringOnChange = maskedValue;
      this.$emit('change', {
        event: event,
        selectionStart: this.currentSelection[0],
        selectionEnd: this.currentSelection[1],
        value: this.computedValue(),
        component: this,
        target: {
          name: this.$props.name,
          value: this.computedValue(),
          rawValue: this.rawValue()
        },
        validity: this.validity()
      });
      this.$emit('changemodel', this.computedValue());
      this.$emit('update:modelValue', this.computedValue());
      this.$emit('update:modelRawValue', this.rawValue());
      this.valueDuringOnChange = undefined;
    },
    updateService: function updateService(extra) {
      var config = Object.assign({
        includeLiterals: this.$props.includeLiterals,
        mask: this.$props.mask,
        prompt: this.$props.prompt,
        promptPlaceholder: this.$props.promptPlaceholder,
        rules: this.$props.rules
      }, extra); // tslint:disable-line:align

      this.service.update(config);
    },
    setValidity: function setValidity() {
      if (this.element) {
        this.element.setCustomValidity(this.validity().valid ? '' : this.$props.validationMessage || '');
      }
    }
  },
  render: function render(createElement) {
    var _this = this;

    var h = gh || createElement;
    var inputId = this.$props.id || this.inputId;
    var isValid = !this.hasMounted || !this.$props.validityStyles || this.validity().valid;
    var newValue = this.computedValue();
    var inputValue = this.inputValue;
    var component = h("span", {
      dir: this.$props.dir,
      attrs: this.v3 ? undefined : {
        dir: this.$props.dir
      },
      "class": classNames('k-widget k-maskedtextbox', this.$props.className, {
        'k-state-focused': this.currentFocused,
        'k-state-disabled': this.$props.disabled,
        'k-state-invalid': !isValid
      }),
      style: !this.$props.label ? {
        width: this.$props.width
      } : undefined
    }, [h("input", {
      type: "text",
      attrs: this.v3 ? undefined : {
        type: "text",
        autoComplete: "off",
        autoCorrect: "off",
        autoCapitalize: "off",
        spellCheck: false,
        id: inputId,
        "aria-labelledby": this.$props.ariaLabelledBy,
        "aria-describedby": this.$props.ariaDescribedBy,
        name: this.$props.name,
        tabIndex: getTabIndex(this.$props.tabIndex, this.$props.disabled, true),
        accessKey: this.$props.accessKey,
        title: this.$props.title,
        disabled: this.$props.disabled || undefined,
        readOnly: this.$props.readonly || undefined,
        placeholder: this.$props.placeholder
      },
      autoComplete: "off",
      autoCorrect: "off",
      autoCapitalize: "off",
      spellCheck: false,
      "class": "k-textbox",
      value: this.v3 ? newValue : null,
      domProps: this.v3 ? undefined : {
        "value": newValue
      },
      id: inputId,
      "aria-labelledby": this.$props.ariaLabelledBy,
      "aria-describedby": this.$props.ariaDescribedBy,
      name: this.$props.name,
      tabIndex: getTabIndex(this.$props.tabIndex, this.$props.disabled, true),
      accessKey: this.$props.accessKey,
      title: this.$props.title,
      disabled: this.$props.disabled || undefined,
      readOnly: this.$props.readonly || undefined,
      placeholder: this.$props.placeholder,
      ref: this.v3 ? function (el) {
        _this.inputRef = el;
      } : 'input',
      onInput: this.onChangeHandler,
      on: this.v3 ? undefined : {
        "input": this.onChangeHandler,
        "paste": this.pasteHandler,
        "focus": this.focusHandler,
        "blur": this.blurHandler,
        "dragStart": returnFalse,
        "drop": returnFalse
      },
      onPaste: this.pasteHandler,
      onFocus: this.focusHandler,
      onBlur: this.blurHandler,
      onDragStart: returnFalse,
      onDrop: returnFalse
    })]);
    return this.$props.label ? h("span", {
      "class": this.spanClassNames,
      dir: this.$props.dir,
      attrs: this.v3 ? undefined : {
        dir: this.$props.dir
      }
    }, [component, this.$props.label ? inputId ? h("label", {
      "for": inputId,
      attrs: this.v3 ? undefined : {
        "for": inputId
      },
      "class": "k-label"
    }, [this.$props.label]) : h("span", {
      "class": "k-label"
    }, [this.$props.label]) : null]) : component;
  }
};
export { MaskedTextBox };