var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return __assign.apply(this, arguments);
}; // @ts-ignore


import * as Vue from 'vue';
var allVue = Vue;
var gh = allVue.h;
var ref = allVue.ref;
import { guid, noop } from '@progress/kendo-vue-common';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from '../package-metadata';
var Input = {
  model: {
    event: 'changemodel'
  },
  inheritAttrs: false,
  // @ts-ignore
  emits: {
    'input': null,
    'change': null,
    'changemodel': null,
    'update:modelValue': null,
    'focus': null,
    'blur': null
  },
  props: {
    modelValue: {
      type: [String, Number],
      default: undefined
    },
    defaultValue: {
      type: [String, Number],
      default: ''
    },
    value: {
      type: [String, Number]
    },
    label: {
      type: String
    },
    placeholder: {
      type: String
    },
    required: {
      type: Boolean,
      default: false
    },
    dir: {
      type: String
    },
    id: String,
    valid: {
      type: Boolean,
      default: undefined
    },
    validate: {
      type: Boolean
    },
    validationMessage: {
      type: String
    },
    validityStyles: {
      type: Boolean,
      default: true
    }
  },
  data: function data() {
    return {
      hasMounted: false,
      autofill: false,
      currentValue: '',
      valueDuringOnChange: '',
      input: null,
      inputId: guid(),
      focused: false
    };
  },
  created: function created() {
    validatePackage(packageMetadata);
    this.$data.valueDuringOnChange = undefined;
    this.$data.currentValue = this.$props.defaultValue;
  },
  mounted: function mounted() {
    this.$data.input = this.v3 ? this.inputRef : this.$refs.input;
    this.$data.hasMounted = true;
    this.setValidity();
  },
  updated: function updated() {
    this.setValidity();
  },
  // @ts-ignore
  setup: !gh ? undefined : function () {
    var v3 = !!gh;
    var inputRef = ref(null);
    return {
      v3: v3,
      inputRef: inputRef
    };
  },
  render: function render(createElement) {
    var _this = this;

    var h = gh || createElement;
    var listeners = this.v3 ? this.$attrs : this.$listeners;
    var hasInput = Object.keys(this.$attrs).some(function (attr) {
      return attr === 'onInput';
    });
    var hasModel = Object.keys(this.$attrs).some(function (attr) {
      return attr === 'onUpdate:modelValue';
    });
    var _a = this.$props,
        label = _a.label,
        id = _a.id,
        required = _a.required;
    var inputId = id || this.$data.inputId;
    var textbox = h('input', __assign(__assign({
      domProps: this.v3 ? null : __assign(__assign({}, this.$attrs), {
        placeholder: this.$props.placeholder,
        id: inputId,
        required: required,
        value: this.computedValue
      })
    }, this.$attrs), {
      placeholder: this.$props.placeholder,
      id: inputId,
      required: required,
      value: this.computedValue,
      class: __assign({}, this.inputClassNames()),
      ref: this.v3 ? function (el) {
        _this.inputRef = el;
      } : 'input',
      on: this.v3 ? null : {
        change: this.handleChange,
        focus: this.emitFocus,
        blur: this.emitBlur,
        input: listeners.input || listeners.changemodel ? this.handleInput : noop,
        animationstart: this.handleAutoFill,
        animationend: this.handleAutoFillEnd
      },
      onChange: this.handleChange,
      onFocus: this.emitFocus,
      onBlur: this.emitBlur,
      onInput: hasInput || hasModel ? this.handleInput : noop,
      onAnimationstart: this.handleAutoFill,
      onAnimationend: this.handleAutoFillEnd
    }));
    return label ? h("span", {
      "class": this.spanClassNames,
      onFocusin: this.handleFocus,
      on: this.v3 ? undefined : {
        "focusin": this.handleFocus,
        "focusout": this.handleBlur
      },
      onFocusout: this.handleBlur,
      dir: this.$props.dir,
      attrs: this.v3 ? undefined : {
        dir: this.$props.dir
      }
    }, [textbox, label ? inputId ? h("label", {
      "for": inputId,
      attrs: this.v3 ? undefined : {
        "for": inputId
      },
      "class": "k-label"
    }, [label]) : h("span", {
      "class": "k-label"
    }, [label]) : null]) : textbox;
  },
  methods: {
    emitFocus: function emitFocus(e) {
      this.$emit('focus', e);
    },
    emitBlur: function emitBlur(e) {
      this.$emit('blur', e);
    },
    handleBlur: function handleBlur(_) {
      this.$data.focused = false;
    },
    handleFocus: function handleFocus(_) {
      this.$data.focused = true;
    },
    focus: function focus() {
      if (this.$data.input) {
        this.$data.input.focus();
      }
    },
    inputClassNames: function inputClassNames() {
      var isValid = !this.$data.hasMounted || !this.$props.validityStyles || this.validity().valid;
      return {
        'k-textbox': true,
        'k-state-invalid': !isValid && isValid !== undefined
      };
    },
    validity: function validity() {
      var result = {
        badInput: this.$data.input ? this.$data.input.validity.badInput : false,
        patternMismatch: this.$data.input ? this.$data.input.validity.patternMismatch : false,
        rangeOverflow: this.$data.input ? this.$data.input.validity.rangeOverflow : false,
        rangeUnderflow: this.$data.input ? this.$data.input.validity.rangeUnderflow : false,
        stepMismatch: this.$data.input ? this.$data.input.validity.stepMismatch : false,
        tooLong: this.$data.input ? this.$data.input.validity.tooLong : false,
        typeMismatch: this.$data.input ? this.$data.input.validity.typeMismatch : false,
        valueMissing: this.$data.input ? this.$data.input.validity.valueMissing : false
      };
      return __assign(__assign({}, result), {
        customError: this.$props.validationMessage !== undefined,
        valid: this.$props.valid !== undefined ? this.$props.valid : this.$data.input ? !this.isInvalid(result) : true
      });
    },
    isInvalid: function isInvalid(state) {
      var result = false;

      for (var prop in state) {
        if (state.hasOwnProperty(prop)) {
          result = result || state[prop];
        }
      }

      return result;
    },
    setValidity: function setValidity() {
      if (this.$data.input && this.$data.input.setCustomValidity) {
        this.$data.input.setCustomValidity(this.validity().valid ? '' : this.$props.validationMessage || '');
      }
    },
    handleInput: function handleInput(event) {
      var that = this;
      this.$data.currentValue = event.target.value;
      this.$data.valueDuringOnChange = event.target.value;
      this.$nextTick(function () {
        that.$emit('input', {
          event: event,
          value: event.target.value,
          component: that,
          target: event.target,
          validity: that.validity()
        });
        that.$emit('changemodel', event.target.value);
        that.$emit('update:modelValue', event.target.value);
        that.$data.valueDuringOnChange = undefined;
      });
    },
    handleChange: function handleChange(event) {
      var that = this;
      this.$data.currentValue = event.target.value;
      this.$data.valueDuringOnChange = event.target.value;
      this.$nextTick(function () {
        that.$emit('change', {
          event: event,
          value: event.target.value,
          component: that,
          target: event.target,
          validity: that.validity()
        });
        that.$emit('changemodel', event.target.value);
        that.$emit('update:modelValue', event.target.value);
        that.$data.valueDuringOnChange = undefined;
      });
    },
    handleAutoFill: function handleAutoFill(e) {
      if (e.animationName === 'autoFillStart') {
        var parent_1 = e.target.parentNode;

        if (parent_1 && parent_1.classList.contains('k-state-empty')) {
          this.$data.autofill = true;
        }
      }
    },
    handleAutoFillEnd: function handleAutoFillEnd(e) {
      if (e.animationName === 'autoFillEnd') {
        var parent_2 = e.target.parentNode;

        if (parent_2) {
          this.$data.autofill = false;
        }
      }
    },
    name: function name() {
      return this.$props.name;
    }
  },
  computed: {
    spanClassNames: {
      get: function get() {
        var isValid = !this.$data.hasMounted || !this.$props.validityStyles || this.validity().valid;
        return {
          'k-floating-label-container': true,
          'k-state-focused': this.$data.focused,
          'k-state-empty': !((this.computedValue === 0 ? true : this.computedValue) || this.$props.placeholder || this.$data.autofill),
          'k-autofill': this.$data.autofill,
          'k-state-invalid': !isValid && isValid !== undefined,
          'k-rtl': this.$props.dir === 'rtl'
        };
      }
    },
    computedValue: {
      get: function get() {
        return this.$data.valueDuringOnChange !== undefined ? this.$data.valueDuringOnChange : this.$props.value !== undefined ? this.$props.value : this.$props.modelValue !== undefined ? this.$props.modelValue : this.$data.currentValue;
      }
    }
  }
};
export { Input };