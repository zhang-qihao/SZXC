// @ts-ignore
import * as Vue from 'vue';
var allVue = Vue;
var gh = allVue.h;
import { Slide } from '@progress/kendo-vue-animation';
import { CollisionType, AlignPoint, throttle, FRAME_DURATION, isWindowAvailable } from './util';
import { AlignService } from './services/alignService';
import { DOMService } from './services/domService';
import { PositionService } from './services/positionService';
import { getDefaultSlots } from '@progress/kendo-vue-common';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from './package-metadata';
var DEFAULT_OFFSET = {
  left: -1000,
  top: 0
};
var ANIMATION_CONTAINER = 'k-animation-container';
var ANIMATION_CONTAINER_SHOWN = 'k-animation-container-shown';
var K_POPUP = 'k-popup';
/**
 * Represents the default `Animation` component.
 */

var Popup = {
  name: 'Popup',
  props: {
    appendTo: {
      type: String,
      default: ''
    },
    anchor: {
      type: String,
      default: ''
    },
    className: String,
    id: String,
    popupClass: String,
    collision: {
      type: Object,
      default: function _default() {
        return {
          horizontal: CollisionType.fit,
          vertical: CollisionType.flip
        };
      }
    },
    anchorAlign: {
      type: Object,
      default: function _default() {
        return {
          horizontal: AlignPoint.left,
          vertical: AlignPoint.bottom
        };
      }
    },
    popupAlign: {
      type: Object,
      default: function _default() {
        return {
          horizontal: AlignPoint.left,
          vertical: AlignPoint.top
        };
      }
    },
    offset: {
      type: Object,
      default: function _default() {
        return DEFAULT_OFFSET;
      }
    },
    show: {
      type: Boolean,
      default: false
    },
    animate: {
      type: [Boolean, Object],
      default: function _default() {
        return true;
      }
    },
    direction: {
      type: String,
      default: 'down'
    },
    transition: {
      type: String,
      default: 'expand'
    }
  },
  created: function created() {
    validatePackage(packageMetadata);
    this.mountedAppendTo = undefined;
    this.mountedAnchor = undefined;
    this._flipped = false;
    this._offsetTop = 0;
    this._offsetLeft = -1000;
    this._exitingAnimation = false;
    this._prevShow = false;
    this._prevShow = this.$props.show;
    this._domService = new DOMService();
    this._alignService = new AlignService(this._domService);
    this._positionService = new PositionService(this._domService);
    this.reposition = throttle(this.reposition.bind(this), FRAME_DURATION);
  },
  // @ts-ignore
  setup: !gh ? undefined : function () {
    var v3 = !!gh;
    return {
      v3: v3
    };
  },
  mounted: function mounted() {
    this.mountedAppendTo = this.$props.appendTo ? this.getParentRef(this.$props.appendTo) : document.body;
    this.mountedAnchor = this.$props.anchor ? this.getParentRef(this.$props.anchor) : document.body;
    this._parentElement = this.$el.parentElement;
    this.mountedAppendTo.appendChild(this.$el);
  },
  updated: function updated() {
    this._prevShow = this.$props.show;
  },
  destroyed: !!gh ? undefined : function () {
    this.detachRepositionHandlers();
  },
  beforeDestroy: !!gh ? undefined : function () {
    if (this._parentElement) {
      this._parentElement.appendChild(this.$el);
    }
  },
  // @ts-ignore
  unmounted: function unmounted() {
    this.detachRepositionHandlers();
  },
  // @ts-ignore
  beforeUnmount: function beforeUnmount() {
    if (this._parentElement) {
      this._parentElement.appendChild(this.$el);
    }
  },
  methods: {
    onOpened: function onOpened() {
      var element = this.$el;

      if (this.$props.show) {
        element.classList.add(ANIMATION_CONTAINER_SHOWN);
      }

      this.attachRepositionHandlers(element);
      this.$emit('open', {
        target: this
      });
    },
    onClosing: function onClosing() {
      if (!this.$props.show) {
        var element = this.$el;
        element.classList.remove(ANIMATION_CONTAINER_SHOWN);
      }

      this.detachRepositionHandlers();
    },
    onClosed: function onClosed() {
      if (this._exitingAnimation) {
        this._exitingAnimation = false;
        this.$forceUpdate();
      }

      this.$emit('close', {
        target: this
      });
    },
    transitionDuration: function transitionDuration() {
      var animate = this.$props.animate;
      var transitionEnterDuration = 0;
      var transitionExitDuration = 0;

      if (animate) {
        if (animate === true) {
          // Inherit the default duration of the Animation component.
          transitionEnterDuration = transitionExitDuration = undefined;
        } else {
          transitionEnterDuration = animate.openDuration;
          transitionExitDuration = animate.closeDuration;
        }
      }

      return {
        transitionEnterDuration: transitionEnterDuration,
        transitionExitDuration: transitionExitDuration
      };
    },
    getParentRef: function getParentRef(anchor) {
      // @ts-ignore
      var parent = this.$parent;

      while (!parent.$refs[anchor]) {
        // @ts-ignore
        if (parent && parent.kendoAnchorRef) {
          // @ts-ignore
          return parent.kendoAnchorRef;
        } // @ts-ignore


        parent = parent.$parent;

        if (!parent) {
          return document.body;
        }
      } // @ts-ignore


      return parent.$refs[anchor].$el || parent.$refs[anchor];
    },
    position: function position(settings, element, anchor) {
      var anchorAlign = settings.anchorAlign,
          popupAlign = settings.popupAlign,
          collision = settings.collision,
          offset = settings.offset;
      var anchorElement = anchor ? this.v3 ? this.mountedAnchor : this.getParentRef(anchor) : document.body;

      var alignedOffset = this._alignService.alignElement({
        anchor: anchorElement,
        element: element,
        elementAlign: popupAlign,
        anchorAlign: anchorAlign,
        offset: offset
      });

      var result = this._positionService.positionElement({
        anchor: anchorElement,
        anchorAlign: anchorAlign,
        collisions: collision,
        element: element,
        currentLocation: alignedOffset,
        elementAlign: popupAlign
      });

      return result;
    },
    calculatePosition: function calculatePosition($props, appendToElement) {
      if (!this.$props.anchor || !appendToElement || !isWindowAvailable()) {
        return {
          flipped: false,
          offset: $props.offset
        };
      }

      var defaultSlot = getDefaultSlots(this);
      var root = document.createElement('div');
      appendToElement.appendChild(root); // @ts-ignore

      var internalClass = this.v3 ? defaultSlot && defaultSlot[0].props ? defaultSlot[0].props.class : '' : defaultSlot && defaultSlot[0].data ? defaultSlot[0].data.staticClass : ''; // @ts-ignore

      var domClass = this.v3 ? this.$props.popupClass ? this.$props.popupClass : '' : defaultSlot && defaultSlot[0].data ? defaultSlot[0].data.class : '';
      root.innerHTML = "<div class=\"k-animation-container k-animation-container-relative\">\t\n                    <div class=\"k-popup k-animation-container k-animation-container-relative\">\n                        <div class=\"" + internalClass + " " + domClass + "\" >\n                        </div>\t\n                    </div>\t\n            </div>";

      if (root && root.firstChild) {
        var firstChild = root.firstChild;
        firstChild.style.position = 'absolute';
        firstChild.style.visibility = 'hidden';
        firstChild.style.left = '-1000';
        firstChild.style.top = '0';
      }

      var newPosition = this.position($props, root.firstChild, this.$props.anchor);
      root.parentNode.removeChild(root);
      return newPosition;
    },
    attachRepositionHandlers: function attachRepositionHandlers(element) {
      var _this = this;

      this.detachRepositionHandlers();
      this._scrollableParents = this._domService.scrollableParents(this.$props.anchor ? this.mountedAnchor : element);

      this._scrollableParents.map(function (p) {
        return p.addEventListener('scroll', _this.reposition);
      });

      window.addEventListener('resize', this.reposition);
    },
    detachRepositionHandlers: function detachRepositionHandlers() {
      var _this = this;

      if (this._scrollableParents) {
        this._scrollableParents.map(function (p) {
          return p.removeEventListener('scroll', _this.reposition);
        });

        this._scrollableParents = undefined;
      }

      window.removeEventListener('resize', this.reposition);
    },
    reposition: function reposition() {
      this.$forceUpdate();
    }
  },
  // @ts-ignore
  render: function render(createElement) {
    var h = gh || createElement;
    var _a = this.$props,
        className = _a.className,
        popupClass = _a.popupClass,
        show = _a.show,
        id = _a.id;
    var defaultSlots = getDefaultSlots(this);
    var defaultSlot = this.v3 ? defaultSlots : show ? defaultSlots : null;
    var defaultAppentTo = isWindowAvailable() ? this.$props.appendTo ? this.mountedAppendTo || this.getParentRef(this.$props.appendTo) : document.body : undefined;

    if (this.$props.show) {
      var newPosition = this.calculatePosition(this.$props, defaultAppentTo);
      this._offsetLeft = newPosition.offset.left;
      this._offsetTop = newPosition.offset.top;
      this._flipped = !!newPosition.flipped;
    }

    var direction = this._flipped && show ? 'up' : 'down';

    var _b = this.transitionDuration(),
        transitionEnterDuration = _b.transitionEnterDuration,
        transitionExitDuration = _b.transitionExitDuration;

    this._exitingAnimation = this._exitingAnimation || this._prevShow && !show;

    if (show || this._exitingAnimation && defaultAppentTo) {
      var popup = // @ts-ignore function children
      h(Slide, {
        id: id,
        attrs: this.v3 ? undefined : {
          id: id,
          componentChildClassName: [popupClass, K_POPUP],
          className: className,
          direction: direction,
          transitionEnterDuration: transitionEnterDuration,
          transitionExitDuration: transitionExitDuration,
          appear: show
        },
        componentChildClassName: [popupClass, K_POPUP],
        className: className,
        onEntered: this.onOpened,
        on: this.v3 ? undefined : {
          "entered": this.onOpened,
          "exiting": this.onClosing,
          "exited": this.onClosed
        },
        onExiting: this.onClosing,
        onExited: this.onClosed,
        direction: direction,
        style: {
          position: 'absolute',
          top: this._offsetTop + 'px',
          left: this._offsetLeft + 'px'
        },
        transitionEnterDuration: transitionEnterDuration,
        transitionExitDuration: transitionExitDuration,
        appear: show
      }, this.v3 ? function () {
        return [defaultSlot];
      } : [defaultSlot]);
      return popup;
    }

    return null;
  }
};
export { Popup };