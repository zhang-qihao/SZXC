import {
    align,
    applyLocationOffset,
    boundingOffset,
    getWindowViewPort,
    isBodyOffset,
    offset,
    positionWithScroll,
    restrictToView,
    addScroll,
    removeScroll,
    scrollPosition,
    siblingContainer,

    AlignSettings,
    BoundingRect,
    ElementRect,
    OffsetPosition,
    PositionSettings,
    ScrollInfo,
    ViewPort

} from '@progress/kendo-popup-common';

import { Position } from '../models/Position';

import {
    isDocumentAvailable,
    isWindowAvailable,
    HAS_RELATIVE_STACKING_CONTEXT,
    scrollableParents,
    zIndex
} from '../util';

/**
 * @hidden
 */
export class DOMService {
    public addOffset(current: OffsetPosition, addition: OffsetPosition): OffsetPosition {
        return {
            left: current.left + addition.left,
            top: current.top + addition.top
        } as OffsetPosition;
    }

    public align(settings: AlignSettings): OffsetPosition {
        return align(settings) as OffsetPosition;
    }

    public boundingOffset(el: HTMLElement): BoundingRect {
        return boundingOffset(el);
    }

    public getWindow() {
        return isWindowAvailable() ? window : null;
    }

    public isBodyOffset(el: HTMLElement): boolean {
        return isBodyOffset(el);
    }

    public hasOffsetParent(el: HTMLElement): boolean | null {
        if (!el) { return false; }

        const offsetParentEl = el.offsetParent;
        return offsetParentEl &&
            !(offsetParentEl.nodeName === 'BODY' &&
            window.getComputedStyle(offsetParentEl).position === 'static');
    }

    public offset(el: HTMLElement) {
        if (!el) { return null; }

        return offset(el);
    }

    public staticOffset(element: HTMLElement) {
        if (!element) { return null; }

        const { left, top } = element.style;

        element.style.left = '0px';
        element.style.top = '0px';

        const currentOffset = offset(element);

        element.style.left = left;
        element.style.top = top;

        return currentOffset;
    }

    public position(element: HTMLElement, popup: HTMLElement) {
        if (!element || !popup) { return null; }

        const parentSibling = siblingContainer(element, popup);

        return positionWithScroll(element, parentSibling);
    }

    public relativeOffset(el: HTMLElement, currentLocation: OffsetPosition): ElementRect {
        return applyLocationOffset(this.offset(el) as ElementRect, currentLocation, this.isBodyOffset(el));
    }

    public addScroll(rect: ElementRect, scroll: ScrollInfo): ElementRect {
        return addScroll(rect, scroll) as ElementRect;
    }

    public removeScroll(rect: ElementRect, scroll: ScrollInfo): ElementRect {
        return removeScroll(rect, scroll) as ElementRect;
    }

    public restrictToView(settings: PositionSettings): Position {
        return restrictToView(settings) as Position;
    }

    public scrollPosition(el: HTMLElement): ScrollInfo {
        return scrollPosition(el);
    }

    public scrollableParents(el: HTMLElement): Array<HTMLElement> {
        return scrollableParents(el);
    }

    public stackingElementOffset(el: HTMLElement) {
        const relativeContextElement = this.getRelativeContextElement(el);

        if (!relativeContextElement) { return null; }

        return offset(relativeContextElement);
    }

    public stackingElementScroll(el: HTMLElement): ScrollInfo {
        const relativeContextElement = this.getRelativeContextElement(el);

        if (!relativeContextElement) { return { x: 0, y: 0 }; }

        return {
            x: relativeContextElement.scrollLeft,
            y: relativeContextElement.scrollTop
        };
    }

    public stackingElementViewPort(el: HTMLElement) {
        const relativeContextElement = this.getRelativeContextElement(el);

        if (!relativeContextElement) { return null; }

        return {
            height: relativeContextElement.scrollHeight,
            width: relativeContextElement.scrollWidth
        };
    }

    public getRelativeContextElement(el: HTMLElement) {
        if (!el || !HAS_RELATIVE_STACKING_CONTEXT) { return null; }

        let parent = el.parentElement;

        while (parent) {
            if (window.getComputedStyle(parent).transform !== 'none') {
                return parent;
            }
            parent = parent.parentElement;
        }

        return null;
    }

    public useRelativePosition(el: HTMLElement): boolean {
        return !!this.getRelativeContextElement(el);
    }

    public windowViewPort(el: HTMLElement): ViewPort {
        return getWindowViewPort(el);
    }

    public zIndex(anchor: HTMLElement, container: HTMLElement) {
        return zIndex(anchor, container);
    }

    public zoomLevel(): number {
        if (!isDocumentAvailable() || !isWindowAvailable()) { return 1; }

        return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2));
    }

    public isZoomed(): boolean {
        return this.zoomLevel() > 1;
    }
}
