import { ElementRect, OffsetPosition, parents, siblingContainer } from '@progress/kendo-popup-common';

/**
 * @hidden
 */
export const eitherRect = (rect: ElementRect | null, offset: OffsetPosition): ElementRect => {
    if (!rect) {
        return { height: 0, left: offset.left, top: offset.top, width: 0 } as ElementRect;
    }

    return rect;
};

/**
 * @hidden
 */
export const replaceOffset = (rect: ElementRect, offset: OffsetPosition): ElementRect => {
    if (!offset) { return rect; }

    const result = {
        height: rect.height,
        left: offset.left,
        top: offset.top,
        width: rect.width
    } as ElementRect;

    return result;
};

/**
 * @hidden
 */
export const removeStackingOffset = (rect: ElementRect, stackingOffset: ElementRect | null): ElementRect => {
    if (!stackingOffset) { return rect; }

    const result = {
        height: rect.height,
        left: rect.left - stackingOffset.left,
        top: rect.top - stackingOffset.top,
        width: rect.width
    } as ElementRect;

    return result;
};

/**
 * @hidden
 */
export const isDifferentOffset = (oldOffset: OffsetPosition, newOffset: OffsetPosition): boolean => {
    const { left: oldLeft, top: oldTop } = oldOffset;
    const { left: newLeft, top: newTop } = newOffset;

    return Math.abs(oldLeft - newLeft) >= 1 || Math.abs(oldTop - newTop) >= 1;
};

/**
 * @hidden
 */
export const isDocumentAvailable = (): boolean => {
    return typeof document !== 'undefined' && !!document.body;
};

/**
 * @hidden
 */
export const isWindowAvailable = (): boolean => {
    return typeof window !== 'undefined';
};

/**
 * @hidden
 */
export const hasBoundingRect = (elem: HTMLElement): boolean => !!elem.getBoundingClientRect;

/**
 * @hidden
 */
export const OVERFLOW_REGEXP = /auto|scroll/;

/**
 * @hidden
 */
const overflowStyle = (element: HTMLElement): string => {
    const styles = window.getComputedStyle(element);
    return `${styles.overflow}${styles.overflowX}${styles.overflowY}`;
};

/**
 * @hidden
 */
export const scrollableParents = (element: HTMLElement) => {
    const parentElements: any[] = [];

    if (!isDocumentAvailable() || !isWindowAvailable()) { return parentElements; }

    let parent = element.parentElement as HTMLElement;

    while (parent) {
        if (OVERFLOW_REGEXP.test(overflowStyle(parent))) {
            parentElements.push(parent);
        }

        parent = parent.parentElement as HTMLElement;
    }

    parentElements.push(window);

    return parentElements;
};

/**
 * @hidden
 */
export const FRAME_DURATION = 1000 / 60; // 1000ms divided by 60fps

/**
 * @hidden
 */
export const hasRelativeStackingContext = () => {
    if (!isDocumentAvailable()) { return false; }

    const top = 10;
    const parent = document.createElement('div');
    parent.style.transform = 'matrix(10, 0, 0, 10, 0, 0)';
    parent.innerHTML = `<div>child</div>`;

    document.body.appendChild(parent);
    if (parent && parent.firstChild) {
        const firstChild = parent.firstChild as HTMLElement;
        firstChild.style.position = 'fixed'; 
        firstChild.style.top = `${top}px`;
    }

    const isDifferent = parent.children[0].getBoundingClientRect().top !== top;

    document.body.removeChild(parent);

    return isDifferent;
};

/**
 * @hidden
 */
export const HAS_RELATIVE_STACKING_CONTEXT = hasRelativeStackingContext();

/**
 * @hidden
 */
export const zIndex = (anchor: HTMLElement, container: HTMLElement) => {
    if (!anchor || !isDocumentAvailable() || !isWindowAvailable()) { return null; }

    const sibling = siblingContainer(anchor, container);

    if (!sibling) { return null; }

    const result = [anchor].concat(parents(anchor, sibling)).reduce(
        (index, p) => {
            const zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;
            const current = parseInt(zIndexStyle as string, 10);
            return current > index ? current : index;
        },
        0
    );

    return result ? (result + 1) : null;
};

/**
 * @hidden
 */
export const CollisionType = {
    fit: 'fit',
    flip: 'flip'
};

/**
 * @hidden
 */
export const AlignPoint = {
    left: 'left',
    center: 'center',
    right: 'right',
    bottom: 'bottom',
    top: 'top'
};

/**
 * @hidden
 */
export const throttle = function (func: Function, wait: number, options: any = {}) {
    let timeout, context, args, result;
    let previous = 0;
    options = options || {};

    const later = function () {
        previous = options.leading === false ? 0 : new Date().getTime();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) {
            context = args = null;
        }
    };

    const throttled = function () {
        const now = new Date().getTime();
        if (!previous && options.leading === false) {
            previous = now;
        }
        const remaining = wait - (now - previous);
        // @ts-ignore
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout) {
                context = args = null;
            }
        } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
        return result;
    };

    return throttled;
};
