// @ts-ignore
import * as Vue from 'vue';
const allVue = Vue as any;
const gh = allVue.h;
import { RecordPropsDefinition, ComponentOptions } from 'vue/types/options';
type DefaultData<V> =  object | ((this: V) => {});
type DefaultMethods<V> =  { [key: string]: (this: V, ...args: any[]) => any };
import { Slide } from '@progress/kendo-vue-animation';
import { VNode } from 'vue';
import { Offset } from './models/Offset';
import { Position } from './models/Position';
import { PopupProps } from './models/PopupProps';

import { CollisionType, AlignPoint, throttle, FRAME_DURATION, isWindowAvailable } from './util';

import { AlignService } from './services/alignService';
import { DOMService } from './services/domService';
import { PositionService } from './services/positionService';
import { getDefaultSlots } from '@progress/kendo-vue-common';

import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from './package-metadata';

const DEFAULT_OFFSET = {
    left: -1000,
    top: 0
};

const ANIMATION_CONTAINER = 'k-animation-container';
const ANIMATION_CONTAINER_SHOWN = 'k-animation-container-shown';
const K_POPUP = 'k-popup';

/**
 * @hidden
 */
export interface PropsWithChildren extends PopupProps {
    children?: VNode;
}
/**
 * @hidden
 */
export interface PopupMethods {
    onOpened: () => void;
    onClosing: () => void;
    onClosed: () => void;
    transitionDuration: () => any;
    getParentRef: (anchor: string) => any;
    position: (settings: PopupProps, element: HTMLElement, anchor: string) => Position;
    calculatePosition: ($props: any, appendToElement?: HTMLElement) => Position;
    attachRepositionHandlers: (element: any) => void;
    detachRepositionHandlers: () => void;
    reposition: () => void;
}
/**
 * @hidden
 */
export interface PopupState {
    mountedAppendTo: any;
    mountedAnchor: any;
    _parentElement: any;
    _alignService: AlignService;
    _positionService: PositionService;
    _domService: DOMService;
    _flipped: boolean;
    _offsetTop: number;
    _offsetLeft: number;
    _scrollableParents: Array<HTMLElement> | undefined;
    _exitingAnimation: boolean | undefined;
    _prevShow?: boolean;
    v3: boolean;
}
/**
 * @hidden
 */
export interface PopupAll extends PopupMethods, PopupState, Vue {
}

/**
 * Represents the default `Animation` component.
 */
let Popup: ComponentOptions<Vue, DefaultData<{}>, 
DefaultMethods<PopupAll>, {}, RecordPropsDefinition<PopupProps>> = {
    name: 'Popup',
    props: {
        appendTo: {
            type: String,
            default: ''
        },
        anchor: {
            type: String,
            default: ''
        },
        className: String,
        id: String,
        popupClass: String,
        collision:  {
            type: Object,
            default: function () {
                return {
                    horizontal: CollisionType.fit,
                    vertical: CollisionType.flip
                };
            }
        },
        anchorAlign: {
            type: Object,
            default: function() {
                return {
                    horizontal: AlignPoint.left,
                    vertical: AlignPoint.bottom
                };
            }
        },
        popupAlign: {
            type: Object,
            default: function() {
                return {
                    horizontal: AlignPoint.left,
                    vertical: AlignPoint.top
                };
            }
        },
        offset: {
            type: Object,
            default: function() {
                return DEFAULT_OFFSET;
            }
        },
        show: {
            type: Boolean,
            default: false
        },
        animate: {
            type: [ Boolean, Object ],
            default: function() {
                return true;
            }
        },
        direction: {
            type: String,
            default: 'down'
        },
        transition: {
            type: String,
            default: 'expand'
        }
    },
    created(this: PopupAll) {
        validatePackage(packageMetadata);
        this.mountedAppendTo = undefined;
        this.mountedAnchor = undefined;
        this._flipped = false;
        this._offsetTop = 0;
        this._offsetLeft = -1000;
        this._exitingAnimation = false;
        this._prevShow = false;
        this._prevShow = this.$props.show;
        this._domService = new DOMService();
        this._alignService = new AlignService(this._domService);
        this._positionService = new PositionService(this._domService);

        this.reposition = throttle(this.reposition.bind(this), FRAME_DURATION);
    },
    // @ts-ignore
    setup: (!gh) ? undefined : function() {
        const v3 = !!gh;
        return {
            v3
        };
    },
    mounted(this: PopupAll) {
        this.mountedAppendTo = this.$props.appendTo ? this.getParentRef(this.$props.appendTo) : document.body;
        this.mountedAnchor = this.$props.anchor ? this.getParentRef(this.$props.anchor) : document.body;

        this._parentElement = this.$el.parentElement;
        this.mountedAppendTo.appendChild(this.$el);
    },
     updated(this: PopupAll) {
         this._prevShow = this.$props.show;
     },
     destroyed: (!!gh) ? undefined : function(this: PopupAll) {
         this.detachRepositionHandlers();
     },
     beforeDestroy: (!!gh) ? undefined : function(this: PopupAll) {
            if (this._parentElement) {
                this._parentElement.appendChild(this.$el);
            }
    },
     // @ts-ignore
    unmounted(this: PopupAll) {
        this.detachRepositionHandlers();
    },
     // @ts-ignore
    beforeUnmount(this: PopupAll) {
            if (this._parentElement) {
                this._parentElement.appendChild(this.$el);
            }
    },
    methods: {
        onOpened() {
            const element = this.$el;
            if (this.$props.show) {
                element.classList.add(ANIMATION_CONTAINER_SHOWN);
            }
            this.attachRepositionHandlers(element);
            this.$emit('open', { target: this });
        },
        onClosing() {
            if (!this.$props.show) {
                const element = this.$el;
                element.classList.remove(ANIMATION_CONTAINER_SHOWN);
            }
            this.detachRepositionHandlers();
        },
        onClosed() {
            if (this._exitingAnimation) {
                this._exitingAnimation = false;
                this.$forceUpdate();
            }
    
            this.$emit('close', { target: this });
        },
        transitionDuration() {
            const animate = this.$props.animate;
            let transitionEnterDuration: number | undefined = 0;
            let transitionExitDuration: number | undefined = 0;
    
            if (animate) {          
                if (animate === true) {
                    // Inherit the default duration of the Animation component.
                    transitionEnterDuration = transitionExitDuration = undefined;
                } else {
                    transitionEnterDuration = animate.openDuration;
                    transitionExitDuration = animate.closeDuration;
                }
            }
    
            return { transitionEnterDuration, transitionExitDuration };
        },
        getParentRef(anchor: string): any {
            // @ts-ignore
            let parent = this.$parent; 
    
            while (!parent.$refs[anchor]) {
                 // @ts-ignore
                if (parent && parent.kendoAnchorRef) {
                        // @ts-ignore
                    return parent.kendoAnchorRef;
                }
                // @ts-ignore
                parent = parent.$parent;

                if (!parent) {
                    return document.body;
                }
            }
             // @ts-ignore
            return parent.$refs[anchor].$el || parent.$refs[anchor];
        },
        position(settings: PopupProps, element: HTMLElement, anchor: string): Position {
            let { anchorAlign, popupAlign, collision, offset } = settings;
    
            let anchorElement = anchor ? (this.v3 ? this.mountedAnchor : this.getParentRef(anchor)) : document.body;

            const alignedOffset = this._alignService.alignElement({
                anchor: anchorElement,
                element: element,
                elementAlign: popupAlign! as any,
                anchorAlign: anchorAlign! as any,
                offset
            });
    
            const result = this._positionService.positionElement({
                anchor: anchorElement,
                anchorAlign: anchorAlign! as any,
                collisions: collision! as any,
                element: element,
                currentLocation: alignedOffset,
                elementAlign: popupAlign! as any
            });
    
            return result;
        },
        calculatePosition ($props: PropsWithChildren, appendToElement?: HTMLElement): Position {
            if (!this.$props.anchor || !appendToElement || !isWindowAvailable()) {
                return {
                    flipped: false,
                    offset: $props.offset
                };
            }
            const defaultSlot = getDefaultSlots(this);
    
            const root = document.createElement('div');
    
            appendToElement.appendChild(root);
            // @ts-ignore
            const internalClass = this.v3 ? 
                (defaultSlot && defaultSlot[0].props) ? defaultSlot[0].props.class : '' : 
                (defaultSlot && defaultSlot[0].data) ? defaultSlot[0].data.staticClass : '';
            // @ts-ignore
            const domClass = this.v3 ? 
                this.$props.popupClass ? this.$props.popupClass : '' : 
                (defaultSlot && defaultSlot[0].data) ? defaultSlot[0].data.class : '';

            root.innerHTML = `<div class="k-animation-container k-animation-container-relative">	
                    <div class="k-popup k-animation-container k-animation-container-relative">
                        <div class="${internalClass} ${domClass}" >
                        </div>	
                    </div>	
            </div>`;

            if (root && root.firstChild) {
                const firstChild = root.firstChild as HTMLElement;
                firstChild.style.position = 'absolute';
                firstChild.style.visibility = 'hidden';
                firstChild.style.left = '-1000';
                firstChild.style.top = '0';
            }
    
            const newPosition = this.position($props, root.firstChild as HTMLElement, this.$props.anchor);
    
            root.parentNode!.removeChild(root);
    
            return newPosition;
        },
        attachRepositionHandlers(element: any) { 
            this.detachRepositionHandlers();
            this._scrollableParents = this._domService.scrollableParents(
            this.$props.anchor ? this.mountedAnchor : element);
            this._scrollableParents.map(p => p.addEventListener('scroll', this.reposition));
            window.addEventListener('resize', this.reposition);
        },
        detachRepositionHandlers() {
            if (this._scrollableParents) {
                this._scrollableParents.map(p => p.removeEventListener('scroll', this.reposition));
                this._scrollableParents = undefined;
            }
            window.removeEventListener('resize', this.reposition);
        },
        reposition() {
            this.$forceUpdate();
        }
    },
    // @ts-ignore
    render(this: PopupAll, createElement: any): any {
        const h = gh || createElement;
        const { className,
            popupClass, show, id } = this.$props;
        const defaultSlots = getDefaultSlots(this);
        const defaultSlot = this.v3 ? defaultSlots : (show ? defaultSlots : null);
        const defaultAppentTo = isWindowAvailable() ?
         (this.$props.appendTo ? 
            (this.mountedAppendTo ||  this.getParentRef(this.$props.appendTo))
          : document.body) : undefined;

        if (this.$props.show) {
            const newPosition = this.calculatePosition(this.$props, defaultAppentTo);
            
            this._offsetLeft = newPosition.offset!.left;
            this._offsetTop = newPosition.offset!.top;
            this._flipped = !!newPosition.flipped;  
        }

        const direction = this._flipped && show ? 'up' : 'down';
        const { transitionEnterDuration, transitionExitDuration } = this.transitionDuration();

        this._exitingAnimation = this._exitingAnimation || (this._prevShow && !show);
       
        if ((show || this._exitingAnimation && defaultAppentTo ) ) {
            const popup = (
            // @ts-ignore function children
            <Slide  id={id}
                componentChildClassName={[popupClass, K_POPUP]}             
                className={className}
                onEntered={this.onOpened}
                onExiting={this.onClosing}
                onExited={this.onClosed}
                direction={direction}
                style={{
                    position: 'absolute',
                    top: this._offsetTop + 'px',
                    left: this._offsetLeft + 'px'
                }}
                transitionEnterDuration={transitionEnterDuration}
                transitionExitDuration={transitionExitDuration}
                appear={show}>
                    {defaultSlot}
                </Slide>
            );

            return popup; 
        }

        return null;
    }
};

export { Popup };
