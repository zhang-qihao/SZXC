var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return __assign.apply(this, arguments);
}; // @ts-ignore


import * as Vue from 'vue';
var allVue = Vue;
var h = allVue.h;
var createApp = allVue.createApp;
import { exportElement } from './export-element';
/**
 * @hidden
 */

export function provideSaveGridPDF(savePDF) {
  return function (grid, pdfExportOptions, callback, data, columns) {
    if (pdfExportOptions === void 0) {
      pdfExportOptions = {};
    }

    return saveGridPDF(savePDF, grid, pdfExportOptions, callback, data, columns);
  };
}

function saveGridPDF(savePDF, grid, pdfExportOptions, callback, data, v3) {
  if (pdfExportOptions === void 0) {
    pdfExportOptions = {};
  }

  renderGrid();
  var gridOuterWrapper;
  var gridInnerWrapper;
  var finalContainer;
  var gridInstance;

  function renderGrid() {
    gridOuterWrapper = document.createElement('div');
    gridOuterWrapper.setAttribute('style', 'position:absolute; left: -5000px; top: 0px;');
    gridInnerWrapper = document.createElement('div');
    gridOuterWrapper.appendChild(gridInnerWrapper);
    document.body.appendChild(gridOuterWrapper);
    var customDataProps = data && {
      dataItems: data,
      total: data.length,
      pageSize: data.length,
      skip: 0
    };

    if (v3) {
      var gridForPdf = {
        render: function render() {
          return h(grid.type, __assign(__assign({}, grid.props), customDataProps));
        },
        store: grid.$store,
        mounted: function mounted() {
          // @ts-ignore
          if (this.$el.style) {
            // @ts-ignore
            this.$el.style.width = '1000px';
          }

          onGridRendered.call(this);
        }
      };
      gridInstance = createApp(gridForPdf);
      gridInstance.mount(gridInnerWrapper);
    } else {
      var gridConstructor = Object.getPrototypeOf(grid).constructor;
      gridInstance = new gridConstructor({
        propsData: Object.assign({}, grid.$props, customDataProps),
        store: grid.$store,
        mounted: function mounted() {
          if (gridInstance.$el.style) {
            gridInstance.$el.style.width = '1000px';
          }

          onGridRendered.call(gridInstance);
        }
      });
      gridInstance.$mount(gridInnerWrapper);
    }
  }

  function onGridRendered() {
    savePDF(prepareFinalElementForExport.call(this), pdfExportOptions, cleanUpAndInvokeCallback);
  }

  function cleanUpAndInvokeCallback() {
    if (gridInstance.unmount) {
      gridInstance.unmount();
    } else {
      gridInstance.$destroy();
    }

    document.body.removeChild(gridOuterWrapper);
    document.body.removeChild(finalContainer);
    gridOuterWrapper = finalContainer = undefined;

    if (callback) {
      callback();
    }
  }

  function prepareFinalElementForExport() {
    /* Ultimatelly, there is no need for double DOM-copying of the grid.
    The one in this method is a copied Angular implementation
    that has been plugged almost seemlessly. */
    finalContainer = document.createElement('div');
    finalContainer.className = 'k-grid-pdf-export-element';
    var result = exportElement(this.$el);
    finalContainer.appendChild(result);
    document.body.appendChild(finalContainer);
    return result;
  }
}