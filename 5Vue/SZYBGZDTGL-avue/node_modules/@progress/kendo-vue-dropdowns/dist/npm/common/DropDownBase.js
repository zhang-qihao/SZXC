"use strict";

var __assign = undefined && undefined.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var VirtualScroll_1 = require("./VirtualScroll");

var Navigation_1 = require("./Navigation");

var utils_1 = require("./utils");

var kendo_vue_common_1 = require("@progress/kendo-vue-common");

var kendo_licensing_1 = require("@progress/kendo-licensing");

var package_metadata_1 = require("../package-metadata");
/**
 * @hidden
 */


var DropDownBase =
/** @class */
function () {
  function DropDownBase(component) {
    var _this = this;

    this.vs = new VirtualScroll_1.default();
    this.navigation = new Navigation_1.Navigation();

    this.handleItemClick = function (index, event) {
      var state = _this.initState();

      state.event = event;

      _this.component.handleItemSelect(index, state);

      _this.togglePopup(state);

      _this.applyState(state);
    };

    this.handleFocus = function (event) {
      if (!_this.component.currentFocused) {
        var state = _this.initState(); // @ts-ignore


        state.data.currentFocused = true;
        state.events.push({
          type: 'focus'
        });
        state.event = event;

        _this.applyState(state);
      }
    };

    this.filterChanged = function (text, state) {
      // @ts-ignore
      var _a = _this.component.$props,
          textField = _a.textField,
          filterable = _a.filterable;

      if (filterable) {
        state.events.push({
          type: 'filterchange',
          filter: {
            field: textField,
            operator: 'contains',
            ignoreCase: true,
            value: text
          }
        });
      }
    };

    this.togglePopup = function (state) {
      // @ts-ignore
      var props = _this.component.$props; // @ts-ignore

      var opened = props.opened !== undefined ? props.opened : _this.component.currentOpened; // @ts-ignore

      if (props.opened === undefined) {
        // @ts-ignore
        state.data.currentOpened = !opened;
      }

      if (opened) {
        state.events.push({
          type: 'close'
        });
      } else {
        state.events.push({
          type: 'open'
        });

        _this.calculatePopupWidth();
      }
    };

    this.pageChange = function (page, event) {
      var state = _this.initState();

      state.event = event;

      _this.triggerOnPageChange(state, page.skip, page.take);

      _this.applyState(state);
    };

    this.scrollToVirtualItem = function (virtual, selectedItemIndex) {
      var vs = _this.vs;
      vs.enabled = false;

      if (virtual.skip === 0) {
        vs.reset();
      } else if (virtual.skip + virtual.pageSize === virtual.total) {
        vs.scrollToEnd();
      } else {
        var scrollTop = vs.translate;

        if (scrollTop === 0) {
          vs.calcScrollElementHeight();
          scrollTop = vs.itemHeight * virtual.skip;
          vs.translateTo(scrollTop - vs.itemHeight);
        }

        if (vs.container) {
          vs.container.scrollTop = scrollTop;
        }

        _this.scrollToItem(selectedItemIndex, true);
      }

      setTimeout(function () {
        return vs.enabled = true;
      }, 10);
    };

    kendo_licensing_1.validatePackage(package_metadata_1.packageMetadata);
    this.listBoxId = kendo_vue_common_1.guid();
    this.guid = kendo_vue_common_1.guid();
    this.component = component;
    this.vs.PageChange = this.pageChange;
  }

  DropDownBase.prototype.didMount = function () {
    // @ts-ignore
    var props = this.component.$props;
    var popupSettings = props.popupSettings || {};
    var style = props.style || {};
    var popupWidth = popupSettings.width;
    var shouldUpdate = props.opened === true;

    if (popupWidth === undefined) {
      this.calculatePopupWidth();
    }

    if (props.dir === undefined && style.direction === undefined) {
      this.calculateDir();
      shouldUpdate = true;
    }

    if (shouldUpdate) {
      // @ts-ignore
      this.component.$forceUpdate();
    }
  };

  DropDownBase.prototype.calculateDir = function () {
    if (this.component.element) {
      this.dirCalculated = window.getComputedStyle(this.component.element).direction || undefined;
    }
  };

  DropDownBase.prototype.calculatePopupWidth = function () {
    if (this.wrapper) {
      this.popupWidth = this.wrapper.offsetWidth + 'px';
    }
  };

  DropDownBase.prototype.scrollToItem = function (itemIndex, vsEnabled) {
    var list = this.list || this.vs.list;
    var item = list ? list.children[0] : undefined;

    if (item && itemIndex >= 0) {
      var vs = this.vs;
      var scrollElement = vs.container || list.parentNode;
      var virtualScroll = vsEnabled !== undefined ? vsEnabled : vs.enabled;
      utils_1.scrollToItem(scrollElement, item.offsetHeight, itemIndex, vs.translate, virtualScroll);
    }
  };

  DropDownBase.prototype.initState = function () {
    var state = {
      data: {},
      events: [],
      event: undefined
    };
    return state;
  };

  DropDownBase.prototype.applyState = function (state) {
    var _this = this;

    if (Object.keys(state.data).length > 0) {
      Object.keys(state.data).forEach(function (key) {
        _this.component[key] = state.data[key];
      });
    } // @ts-ignore


    var newValue = this.component.computedValue();
    var eventArgs = {
      event: state.event,
      component: this.component,
      target: {
        // @ts-ignore
        name: this.component.$props.name,
        value: newValue
      },
      value: newValue
    };
    state.events.forEach(function (eventData) {
      var type = eventData.type;
      delete eventData.type;

      if (type) {
        // @ts-ignore
        _this.component.$emit(type, __assign(__assign({}, eventArgs), eventData));

        if (type === 'change') {
          // @ts-ignore
          _this.component.$emit('changemodel', newValue); // @ts-ignore


          _this.component.$emit('update:modelValue', newValue);
        }
      }
    });
  };

  DropDownBase.prototype.triggerOnPageChange = function (state, skip, take) {
    // @ts-ignore
    var virtual = this.component.$props.virtual;

    if (virtual) {
      var newSkip = Math.min(Math.max(0, skip), Math.max(0, virtual.total - take));

      if (newSkip !== virtual.skip) {
        state.events.push({
          type: 'pagechange',
          page: {
            skip: newSkip,
            take: take
          }
        });
      }
    }
  };

  DropDownBase.prototype.triggerPageChangeCornerItems = function (item, state) {
    // @ts-ignore
    var props = this.component.$props;
    var _a = props.dataItems,
        dataItems = _a === void 0 ? [] : _a,
        dataItemKey = props.dataItemKey,
        virtual = props.virtual;
    var opened = props.opened !== undefined ? props.opened : this.component.currentOpened;

    if (item && virtual && this.vs.enabled) {
      if (virtual.skip > 0 && utils_1.areSame(item, dataItems[0], dataItemKey)) {
        this.triggerOnPageChange(state, virtual.skip - 1, virtual.pageSize);
      } else if (!opened && virtual.skip + virtual.pageSize < virtual.total && utils_1.areSame(item, dataItems[dataItems.length - 1], dataItemKey)) {
        this.triggerOnPageChange(state, virtual.skip + 1, virtual.pageSize);
      }
    }
  };

  DropDownBase.defaultProps = {
    popupSettings: {
      animate: true,
      height: '200px'
    },
    required: false,
    validityStyles: true
  };
  return DropDownBase;
}();

exports.default = DropDownBase;