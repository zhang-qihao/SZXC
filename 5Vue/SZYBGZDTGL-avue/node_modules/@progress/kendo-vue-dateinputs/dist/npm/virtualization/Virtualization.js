"use strict";

var _a, _b, _c;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Virtualization = exports.ScrollDirection = void 0; // @ts-ignore

var Vue = require("vue");

var allVue = Vue;
var gh = allVue.h;

var kendo_vue_common_1 = require("@progress/kendo-vue-common");

var services_1 = require("./services");
/**
 * @hidden
 */


var ScrollDirection;

(function (ScrollDirection) {
  ScrollDirection[ScrollDirection["Backward"] = 0] = "Backward";
  ScrollDirection[ScrollDirection["Forward"] = 1] = "Forward";
})(ScrollDirection = exports.ScrollDirection || (exports.ScrollDirection = {}));

var differenceToScroll = function differenceToScroll(scrollTop, staticOffset, maxScrollDifference) {
  return Math.min(Math.abs(staticOffset - scrollTop), maxScrollDifference);
};

var FRAME_DURATION = 17;
var scrollModifiers = (_a = {}, _a[ScrollDirection.Forward] = function (step) {
  return function (value) {
    return value + step;
  };
}, _a[ScrollDirection.Backward] = function (step) {
  return function (value) {
    return value - step;
  };
}, _a);
var scrollNormalizers = (_b = {}, _b[ScrollDirection.Forward] = function (end) {
  return function (value) {
    return Math.min(value, end);
  };
}, _b[ScrollDirection.Backward] = function (end) {
  return function (value) {
    return Math.max(value, end);
  };
}, _b);
var scrollValidators = (_c = {}, _c[ScrollDirection.Forward] = function (end) {
  return function (start) {
    return start < end;
  };
}, _c[ScrollDirection.Backward] = function (end) {
  return function (start) {
    return start > end;
  };
}, _c);
var Virtualization = {
  name: 'Virtualization',
  // @ts-ignore
  emits: {
    scroll: null,
    scrollaction: null
  },
  props: {
    bottomOffset: {
      type: Number,
      required: true
    },
    direction: {
      type: String,
      default: function _default() {
        return 'vertical';
      }
    },
    forceScroll: {
      type: Boolean,
      default: false
    },
    itemHeight: Number,
    itemWidth: Number,
    maxScrollDifference: {
      type: Number,
      default: 100
    },
    scrollDuration: {
      type: Number,
      default: 100
    },
    scrollOffsetSize: {
      type: Number,
      default: 0
    },
    skip: {
      type: Number,
      required: true
    },
    tabIndex: Number,
    take: {
      type: Number,
      required: true
    },
    topOffset: {
      type: Number,
      required: true
    },
    total: {
      type: Number,
      required: true
    },
    role: String
  },
  created: function created() {
    this.animationInProgress = false;
    this.lastTotal = undefined;
    this.scrollerService = new services_1.ScrollerService(this.handleScrollAction, this.handlePageAction);
  },
  mounted: function mounted() {
    this.scrollContainer = this.$refs.scrollContainer;
  },
  computed: {
    element: function element() {
      return this.scrollContainer;
    }
  },
  methods: {
    containerOffsetSize: function containerOffsetSize() {
      return this.getContainerProperty(this.$props.direction === 'vertical' ? 'offsetHeight' : 'offsetWidth');
    },
    containerScrollSize: function containerScrollSize() {
      return this.getContainerProperty(this.$props.direction === 'vertical' ? 'scrollHeight' : 'scrollWidth');
    },
    containerScrollPosition: function containerScrollPosition() {
      return this.getContainerProperty(this.$props.direction === 'vertical' ? 'scrollTop' : 'scrollLeft');
    },
    activeIndex: function activeIndex() {
      return this.itemIndex(Math.ceil(this.containerScrollPosition()));
    },
    itemIndex: function itemIndex(offset) {
      if (!this.rowHeightService) {
        return 0;
      }

      return this.rowHeightService.index(offset);
    },
    itemOffset: function itemOffset(index) {
      if (!this.rowHeightService) {
        return 0;
      }

      return this.rowHeightService.offset(index);
    },
    isIndexVisible: function isIndexVisible(index) {
      if (!this.rowHeightService) {
        return false;
      }

      var containerTop = this.containerScrollPosition();
      var containerBottom = containerTop + this.containerOffsetSize();
      var top = this.rowHeightService.offset(index);
      var bottom = top + this.rowHeightService.height(index);
      return top >= containerTop && bottom <= containerBottom;
    },
    isListScrolled: function isListScrolled(index) {
      if (!this.rowHeightService) {
        return false;
      }

      return this.containerScrollPosition() !== this.rowHeightService.offset(index);
    },
    scrollTo: function scrollTo(value) {
      var scrollProperty = this.$props.direction === 'vertical' ? 'scrollTop' : 'scrollLeft';

      if (!this.scrollContainer) {
        return;
      }

      this.scrollContainer[scrollProperty] = value;
    },
    scrollToIndex: function scrollToIndex(index) {
      if (!this.rowHeightService) {
        return;
      }

      this.animationInProgress = false;
      this.scrollTo(this.rowHeightService.offset(index));
    },
    animateToIndex: function animateToIndex(index) {
      var _this = this;

      if (!this.rowHeightService || !window) {
        return;
      }

      window.cancelAnimationFrame(this.cancelAnimation);
      var indexOffset = this.rowHeightService.offset(index);
      var direction = this.getContainerScrollDirection(indexOffset);

      var _a = this.scrollRange(indexOffset, direction),
          start = _a.start,
          end = _a.end;

      if (start === end) {
        return;
      }

      var step = this.scrollStep(start, end);
      var modifyScroll = scrollModifiers[direction](step);
      var normalizeScroll = scrollNormalizers[direction](end);
      var isScrollValid = scrollValidators[direction](modifyScroll(end));

      var animate = function animate(progress) {
        _this.animationInProgress = true;
        var next = modifyScroll(progress);

        _this.scrollTo(normalizeScroll(next));

        isScrollValid(next) ? _this.cancelAnimation = window.requestAnimationFrame(function () {
          animate(next);
        }) : _this.animationInProgress = false;
      };

      this.cancelAnimation = window.requestAnimationFrame(function () {
        animate(start);
      });
    },
    scrollToBottom: function scrollToBottom() {
      if (!this.rowHeightService) {
        return;
      }

      this.scrollTo(this.rowHeightService.totalHeight() + this.$props.bottomOffset);
    },
    scrollStep: function scrollStep(start, end) {
      var duration = this.$props.scrollDuration;
      return Math.abs(end - start) / (duration / FRAME_DURATION);
    },
    scrollRange: function scrollRange(indexOffset, direction) {
      var containerScroll = this.containerScrollPosition();

      if (parseInt("" + indexOffset, 10) === parseInt("" + containerScroll, 10)) {
        return {
          start: indexOffset,
          end: indexOffset
        };
      }

      var maxScroll = this.containerMaxScroll();
      var sign = direction === ScrollDirection.Backward ? 1 : -1;
      var difference = differenceToScroll(containerScroll, indexOffset, this.$props.maxScrollDifference);
      var end = Math.min(indexOffset, maxScroll);
      var start = Math.min(Math.max(end + sign * difference, 0), maxScroll);
      return {
        start: start,
        end: end
      };
    },
    containerMaxScroll: function containerMaxScroll() {
      return this.containerScrollSize() - this.containerOffsetSize();
    },
    getContainerScrollDirection: function getContainerScrollDirection(indexOffset) {
      return indexOffset < this.containerScrollPosition() ? ScrollDirection.Backward : ScrollDirection.Forward;
    },
    initServices: function initServices(newProps) {
      var props = newProps || this.$props;
      var dimension = props.direction === 'vertical' ? props.itemHeight : props.itemWidth;

      if (dimension === undefined) {
        return;
      }

      this.rowHeightService = new services_1.RowHeightService(props.total, dimension, 0);
      this.scrollerService.create(this.rowHeightService, props.skip, props.take, props.total, props.topOffset, this.$props.scrollOffsetSize, this.$props.direction);
    },
    getContainerProperty: function getContainerProperty(propertyName) {
      if (!this.scrollContainer) {
        return 0;
      }

      return this.scrollContainer[propertyName];
    },
    handleScroll: function handleScroll(event) {
      if (!this.scrollContainer || !this.rowHeightService) {
        return;
      }

      var target = event.target;
      this.scrollerService.onScroll({
        scrollLeft: target.scrollLeft,
        scrollTop: target.scrollTop,
        offsetHeight: target.offsetHeight,
        offsetWidth: target.offsetWidth
      });
      var index = this.rowHeightService.index(this.containerScrollPosition() - this.$props.topOffset);
      var args = {
        index: index,
        target: target,
        scrollAction: this.scrollAction,
        pageAction: this.pageAction,
        animationInProgress: this.animationInProgress
      };
      this.$emit('scrollaction', args);
      this.scrollAction = undefined;
      this.pageAction = undefined;
    },
    handleScrollAction: function handleScrollAction(action) {
      this.scrollAction = action;
    },
    handlePageAction: function handlePageAction(action) {
      this.pageAction = action;
    }
  },
  // @ts-ignore
  setup: !gh ? undefined : function () {
    var v3 = !!gh;
    return {
      v3: v3
    };
  },
  // @ts-ignore
  render: function render(createElement) {
    var h = gh || createElement;
    var defaultSlot = kendo_vue_common_1.getDefaultSlots(this);

    if (this.lastTotal !== this.$props.total || this.lastDirection !== this.$props.direction || this.lastTake !== this.$props.take) {
      this.initServices();
      this.lastTotal = this.$props.total;
      this.lastDirection = this.$props.direction;
      this.lastTake = this.$props.take;
    }

    var vertexLength = "" + ((this.rowHeightService ? this.rowHeightService.totalHeight() : 0) + this.$props.bottomOffset);
    var placeholderStyle = this.$props.direction === 'vertical' ? {
      height: vertexLength + "px"
    } : {
      width: vertexLength + "px"
    };
    var rootClassNames = kendo_vue_common_1.classNames('k-content k-scrollable', {
      'k-scrollable-horizontal': this.$props.direction === 'horizontal'
    });
    var scrollableClassNames = kendo_vue_common_1.classNames('k-scrollable-placeholder', {
      'k-scrollable-horizontal-placeholder': this.$props.direction === 'horizontal'
    });
    return h("div", {
      ref: 'scrollContainer',
      onScroll: this.handleScroll,
      on: this.v3 ? undefined : {
        "scroll": this.handleScroll
      },
      "class": rootClassNames,
      tabIndex: this.$props.tabIndex,
      attrs: this.v3 ? undefined : {
        tabIndex: this.$props.tabIndex,
        role: this.$props.role
      },
      role: this.$props.role
    }, [defaultSlot, h("div", {
      style: placeholderStyle,
      "class": scrollableClassNames
    })]);
  }
};
exports.Virtualization = Virtualization;