"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DateTimePicker = void 0; // @ts-ignore

var Vue = require("vue");

var allVue = Vue;
var gh = allVue.h;
var ref = allVue.ref;
var inject = allVue.inject;

var kendo_vue_popup_1 = require("@progress/kendo-vue-popup");

var kendo_date_math_1 = require("@progress/kendo-date-math");

var kendo_vue_common_1 = require("@progress/kendo-vue-common");

var DateInput_1 = require("../dateinput/DateInput");

var kendo_licensing_1 = require("@progress/kendo-licensing");

var package_metadata_1 = require("../package-metadata");

var utils_1 = require("../utils");

var messages_1 = require("../messages");

var kendo_vue_intl_1 = require("@progress/kendo-vue-intl");

var DateTimeSelector_1 = require("./DateTimeSelector");

var utils_2 = require("../timepicker/utils");

var defaults_1 = require("../defaults");

var utils_3 = require("../dateinput/utils"); // tslint:enable:max-line-length


var DateTimePicker = {
  name: 'KendoDateTimePicker',
  props: {
    modelValue: {
      type: Date,
      default: undefined
    },
    defaultShow: {
      type: Boolean,
      default: false
    },
    defaultValue: {
      type: Date,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    dateInput: {
      type: [String, Object, Function],
      default: function _default() {
        return undefined;
      }
    },
    popup: {
      type: [String, Object, Function],
      default: function _default() {
        return undefined;
      }
    },
    calendar: {
      type: [String, Object, Function],
      default: function _default() {
        return undefined;
      }
    },
    focusedDate: Date,
    format: {
      type: [String, Object],
      default: function _default() {
        return 'g';
      }
    },
    formatPlaceholder: {
      type: [String, Object],
      default: function _default() {
        return utils_3.defaultFormatPlaceholder;
      }
    },
    id: String,
    ariaLabelledBy: String,
    ariaDescribedBy: String,
    min: {
      type: Date,
      default: function _default() {
        return utils_1.MIN_DATE;
      }
    },
    max: {
      type: Date,
      default: function _default() {
        return utils_1.MAX_DATE;
      }
    },
    maxTime: {
      type: Date,
      default: function _default() {
        return kendo_date_math_1.cloneDate(utils_1.MAX_TIME);
      }
    },
    minTime: {
      type: Date,
      default: function _default() {
        return kendo_date_math_1.cloneDate(defaults_1.MIN_TIME);
      }
    },
    name: String,
    popupSettings: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    show: {
      type: Boolean,
      default: undefined
    },
    tabIndex: {
      type: Number,
      default: 0
    },
    title: {
      type: String,
      default: function _default() {
        return '';
      }
    },
    steps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    value: Date,
    weekNumber: {
      type: Boolean,
      default: false
    },
    width: String,
    validationMessage: String,
    required: {
      type: Boolean,
      default: false
    },
    validityStyles: {
      type: Boolean,
      default: true
    },
    validate: Boolean,
    valid: {
      type: Boolean,
      default: undefined
    },
    cancelButton: {
      type: Boolean,
      default: true
    }
  },
  model: {
    event: 'changemodel'
  },
  created: function created() {
    this._anchor = kendo_vue_common_1.guid();
    this._popupId = kendo_vue_common_1.guid();
    this._wrapper = null;
    this._dateInput = null;
    this._dateTimeSelector = null;
    kendo_licensing_1.validatePackage(package_metadata_1.packageMetadata);
    this.currentValue = this.$props.defaultValue;
    this.currentShow = this.$props.defaultShow;
  },
  inject: {
    kendoLocalizationService: {
      default: null
    }
  },
  data: function data() {
    return {
      currentValue: null,
      currentShow: false,
      valueDuringOnChange: undefined,
      showDuringOnChange: undefined,
      shouldFocusDateInput: false
    };
  },
  computed: {
    computedValue: function computedValue() {
      var value = this.valueDuringOnChange !== undefined ? this.valueDuringOnChange : this.$props.value !== undefined ? this.$props.value : this.$props.modelValue !== undefined ? this.$props.modelValue : this.$data.currentValue;
      return value !== null ? kendo_date_math_1.cloneDate(value) : null;
    },
    computedShow: function computedShow() {
      return this.showDuringOnChange !== undefined ? this.showDuringOnChange : this.$props.show !== undefined ? this.$props.show : this.currentShow;
    }
  },
  watch: {
    show: function show(_newShow, oldShow) {
      this._oldShow = oldShow;
    },
    currentShow: function currentShow(_newShow, oldShow) {
      this._oldShow = oldShow;
    }
  },
  mounted: function mounted() {
    if (this.computedShow) {
      // If defaultShow is true during the initial render, the popup is not aligned.
      this.$forceUpdate();
    }

    var dateInputElement = this.dateInputElement();
    this._dateTimeSelector = this.$refs.dateTimeSelector;
    this._wrapper = this.$refs[this._anchor];

    if (dateInputElement) {
      dateInputElement.setAttribute('aria-haspopup', 'true');
      dateInputElement.setAttribute('aria-expanded', "" + this.computedShow);
    }
  },
  updated: function updated() {
    var dateInputElement = this.dateInputElement();
    this._dateTimeSelector = this.$refs.dateTimeSelector;
    this._wrapper = this.$refs[this._anchor];

    if (dateInputElement) {
      dateInputElement.setAttribute('aria-expanded', "" + this.computedShow);
    }

    if (this._dateTimeSelector && this.computedShow && !this._oldShow) {
      this._dateTimeSelector.focus({
        preventScroll: true
      });
    }

    if (dateInputElement && !this.computedShow && this.shouldFocusDateInput) {
      this._dateInput.focus({
        preventScroll: true
      });
    }

    this.shouldFocusDateInput = false;
  },
  // @ts-ignore
  setup: !gh ? undefined : function () {
    var v3 = !!gh;
    var kendoAnchorRef = ref(null);
    var kendoLocalizationService = inject('kendoLocalizationService', {});
    return {
      v3: v3,
      kendoAnchorRef: kendoAnchorRef,
      kendoLocalizationService: kendoLocalizationService
    };
  },
  // @ts-ignore
  render: function render(createElement) {
    var _this = this;

    var h = gh || createElement;
    var _a = this.$props,
        disabled = _a.disabled,
        tabIndex = _a.tabIndex,
        title = _a.title,
        id = _a.id,
        format = _a.format,
        formatPlaceholder = _a.formatPlaceholder,
        min = _a.min,
        max = _a.max,
        weekNumber = _a.weekNumber,
        focusedDate = _a.focusedDate,
        width = _a.width,
        name = _a.name,
        steps = _a.steps,
        validationMessage = _a.validationMessage,
        required = _a.required,
        validityStyles = _a.validityStyles,
        cancelButton = _a.cancelButton,
        minTime = _a.minTime,
        maxTime = _a.maxTime,
        ariaLabelledBy = _a.ariaLabelledBy,
        ariaDescribedBy = _a.ariaDescribedBy;
    var _b = this.$props.popupSettings,
        popupClass = _b.popupClass,
        appendTo = _b.appendTo,
        animate = _b.animate;
    var isValid = !this.$props.validityStyles || this.validity().valid;
    var rootClassName = kendo_vue_common_1.classNames('k-widget k-datetimepicker', {
      'k-state-invalid': !isValid
    });
    var wrapperClassNames = kendo_vue_common_1.classNames('k-picker-wrap', {
      'k-state-default': !disabled,
      'k-state-disabled': disabled
    });
    var dateInput = this.$props.dateInput ? kendo_vue_common_1.templateRendering.call(this, this.$props.dateInput, kendo_vue_common_1.getListeners.call(this)) : undefined;
    var dateInputDefaultRendering = // @ts-ignore  function children
    h(DateInput_1.DateInput, {
      ref: 'dateInput',
      disabled: disabled,
      attrs: this.v3 ? undefined : {
        disabled: disabled,
        format: format,
        formatPlaceholder: formatPlaceholder,
        id: id,
        ariaLabelledBy: ariaLabelledBy,
        ariaDescribedBy: ariaDescribedBy,
        max: max,
        min: min,
        minTime: minTime,
        maxTime: maxTime,
        name: name,
        required: required,
        steps: steps,
        tabIndex: !this.computedShow ? tabIndex : -1,
        title: title,
        valid: this.validity().valid,
        validationMessage: validationMessage,
        validityStyles: validityStyles,
        value: this.computedValue
      },
      format: format,
      formatPlaceholder: formatPlaceholder,
      id: id,
      ariaLabelledBy: ariaLabelledBy,
      ariaDescribedBy: ariaDescribedBy,
      max: max,
      min: min,
      minTime: minTime,
      maxTime: maxTime,
      name: name,
      onChange: this.handleValueChange,
      on: this.v3 ? undefined : {
        "change": this.handleValueChange
      },
      required: required,
      steps: steps,
      tabIndex: !this.computedShow ? tabIndex : -1,
      title: title,
      valid: this.validity().valid,
      validationMessage: validationMessage,
      validityStyles: validityStyles,
      value: this.computedValue
    });
    var dateInputRendering = kendo_vue_common_1.getTemplate.call(this, {
      h: h,
      template: dateInput,
      defaultRendering: dateInputDefaultRendering
    });
    var calendar = this.$props.calendar ? kendo_vue_common_1.templateRendering.call(this, this.$props.calendar, kendo_vue_common_1.getListeners.call(this)) : undefined;
    var dataTimeSelector = // @ts-ignore  function children
    h(DateTimeSelector_1.DateTimeSelector, {
      ref: 'dateTimeSelector',
      cancelButton: cancelButton,
      attrs: this.v3 ? undefined : {
        cancelButton: cancelButton,
        value: this.computedValue,
        disabled: disabled,
        weekNumber: weekNumber,
        min: this.$props.min,
        max: this.$props.max,
        minTime: minTime,
        maxTime: maxTime,
        focusedDate: focusedDate,
        format: format,
        calendar: calendar
      },
      value: this.computedValue,
      onChange: this.handleValueChange,
      on: this.v3 ? undefined : {
        "change": this.handleValueChange,
        "reject": this.handleReject,
        "focus": this.timeSelectorFocus,
        "blur": this.timeSelectorBlur,
        "keydown": this.handleKeyDown
      },
      onReject: this.handleReject,
      disabled: disabled,
      weekNumber: weekNumber,
      min: this.$props.min,
      max: this.$props.max,
      minTime: minTime,
      maxTime: maxTime,
      focusedDate: focusedDate,
      format: format,
      calendar: calendar,
      onFocus: this.timeSelectorFocus,
      onBlur: this.timeSelectorBlur,
      onKeydown: this.handleKeyDown
    });
    var popupClassNames = kendo_vue_common_1.classNames('k-datetime-container k-group k-reset', popupClass);
    var popup = this.$props.popup ? kendo_vue_common_1.templateRendering.call(this, this.$props.popup, kendo_vue_common_1.getListeners.call(this)) : undefined;
    var popupDefaultRendering = // @ts-ignore function children
    h(kendo_vue_popup_1.Popup, {
      show: this.computedShow,
      attrs: this.v3 ? undefined : {
        show: this.computedShow,
        anchor: this._anchor,
        id: this._popupId,
        anchorAlign: {
          horizontal: 'left',
          vertical: 'bottom'
        },
        popupAlign: {
          horizontal: 'left',
          vertical: 'top'
        },
        appendTo: appendTo,
        animate: animate
      },
      anchor: this._anchor,
      "class": popupClassNames,
      id: this._popupId,
      anchorAlign: {
        horizontal: 'left',
        vertical: 'bottom'
      },
      popupAlign: {
        horizontal: 'left',
        vertical: 'top'
      },
      appendTo: appendTo,
      animate: animate
    }, this.v3 ? function () {
      return [dataTimeSelector];
    } : [dataTimeSelector]);
    var popupRendering = kendo_vue_common_1.getTemplate.call(this, {
      h: h,
      template: popup,
      defaultRendering: popupDefaultRendering,
      defaultSlots: dataTimeSelector
    });
    return h("div", {
      "class": rootClassName,
      onKeydown: this.handleKeyDown,
      on: this.v3 ? undefined : {
        "keydown": this.handleKeyDown,
        "focusin": this.handleFocus,
        "focusout": this.handleBlur
      },
      style: {
        width: width
      },
      onFocusin: this.handleFocus,
      onFocusout: this.handleBlur
    }, [h("div", {
      ref: this.v3 ? function (el) {
        _this.kendoAnchorRef = el;
      } : this._anchor,
      "class": wrapperClassNames
    }, [dateInputRendering, h("span", {
      role: "button",
      attrs: this.v3 ? undefined : {
        role: "button",
        title: kendo_vue_intl_1.provideLocalizationService(this).toLanguageString(messages_1.toggleDateTimeSelector, messages_1.messages[messages_1.toggleDateTimeSelector]),
        "aria-controls": this._popupId,
        "aria-label": kendo_vue_intl_1.provideLocalizationService(this).toLanguageString(messages_1.toggleDateTimeSelector, messages_1.messages[messages_1.toggleDateTimeSelector])
      },
      onMousedown: this.handleIconMouseDown,
      on: this.v3 ? undefined : {
        "mousedown": this.handleIconMouseDown,
        "click": this.handleDateIconClick
      },
      onClick: this.handleDateIconClick,
      title: kendo_vue_intl_1.provideLocalizationService(this).toLanguageString(messages_1.toggleDateTimeSelector, messages_1.messages[messages_1.toggleDateTimeSelector]),
      "class": "k-select",
      "aria-controls": this._popupId,
      "aria-label": kendo_vue_intl_1.provideLocalizationService(this).toLanguageString(messages_1.toggleDateTimeSelector, messages_1.messages[messages_1.toggleDateTimeSelector])
    }, [h("span", {
      "class": "k-link k-link-date"
    }, [h("span", {
      "class": "k-icon k-i-calendar"
    })])])]), popupRendering]);
  },
  methods: {
    validity: function validity() {
      var inRange = utils_1.isInDateRange(this.computedValue, this.$props.min, this.$props.max) && utils_2.isInTimeRange(this.computedValue, this.$props.minTime || defaults_1.MIN_TIME, this.$props.maxTime || utils_1.MAX_TIME);
      var customError = this.$props.validationMessage !== undefined;
      var isValid = (!this.$props.required || this.computedValue !== null) && inRange;
      var valid = this.$props.valid !== undefined ? this.$props.valid : isValid;
      return {
        customError: customError,
        rangeOverflow: this.computedValue && this.$props.max.getTime() < this.computedValue.getTime() || false,
        rangeUnderflow: this.computedValue && this.computedValue.getTime() < this.$props.min.getTime() || false,
        valid: valid,
        valueMissing: this.computedValue === null
      };
    },
    focus: function focus() {
      var dateInputElement = this.dateInputElement();

      if (dateInputElement) {
        dateInputElement.focus();
      }
    },
    setShow: function setShow(show) {
      if (this.computedShow === show) {
        return;
      }

      this.currentShow = show;
    },
    handleReject: function handleReject() {
      this.setShow(false);
    },
    handleValueChange: function handleValueChange(event) {
      this.currentValue = kendo_date_math_1.cloneDate(event.value || undefined);
      this.currentShow = false;
      this.valueDuringOnChange = event.value;
      this.showDuringOnChange = false;
      this.shouldFocusDateInput = true;
      this.$emit('change', {
        event: event.event,
        value: this.computedValue,
        show: this.computedShow,
        component: this,
        target: {
          name: this.$props.name,
          value: this.computedValue,
          valueAsDate: this.computedValue
        }
      });
      this.$emit('changemodel', this.computedValue);
      this.$emit('update:modelValue', this.computedValue);
      this.valueDuringOnChange = undefined;
      this.showDuringOnChange = undefined;
    },
    handleFocus: function handleFocus(event) {
      if (this._wrapper) {
        this._wrapper.classList.add('k-state-focused');
      }

      this.$emit('focus', event);
    },
    handleBlur: function handleBlur(event) {
      this.createBlurTimeout();
      this.$emit('blur', event);
    },
    timeSelectorBlur: function timeSelectorBlur(event) {
      this.$emit('blur', event);
      clearTimeout(this._blurTimeout);
      this.createBlurTimeout();
    },
    timeSelectorFocus: function timeSelectorFocus() {
      clearTimeout(this._blurTimeout);
    },
    createBlurTimeout: function createBlurTimeout() {
      var _this = this;

      this._blurTimeout = setTimeout(function () {
        if (_this._wrapper) {
          _this._wrapper.classList.remove('k-state-focused');
        }

        if (_this._dateInput && document.activeElement !== _this._dateInput.element() && document.activeElement && document.activeElement.className.indexOf('k-time-list') === -1) {
          _this.setShow(false);
        }
      }, 200);
    },
    handleDateIconClick: function handleDateIconClick() {
      if (this.$props.disabled) {
        return;
      }

      this.shouldFocusDateInput = true;
      this.setShow(!this.computedShow);
    },
    handleIconMouseDown: function handleIconMouseDown(event) {
      event.preventDefault();
    },
    handleKeyDown: function handleKeyDown(event) {
      var altKey = event.altKey,
          keyCode = event.keyCode;

      if (keyCode === kendo_vue_common_1.Keys.tab && event.target !== this._dateInput._element) {
        event.preventDefault();
        this.$data.shouldFocusDateInput = true;
        this.setShow(false);
        return;
      }

      if (keyCode === kendo_vue_common_1.Keys.esc) {
        this.shouldFocusDateInput = true;
        this.setShow(false);
        return;
      }

      if (altKey && (keyCode === kendo_vue_common_1.Keys.up || keyCode === kendo_vue_common_1.Keys.down)) {
        event.preventDefault();
        event.stopPropagation();
        this.shouldFocusDateInput = keyCode === kendo_vue_common_1.Keys.up;
        this.setShow(keyCode === kendo_vue_common_1.Keys.down);
      }
    },
    dateInputElement: function dateInputElement() {
      this._dateInput = this.$refs.dateInput;
      return this._dateInput && this._dateInput.$el || this._wrapper && this._wrapper.querySelector('.k-dateinput-wrap > input.k-input');
    }
  }
};
exports.DateTimePicker = DateTimePicker;