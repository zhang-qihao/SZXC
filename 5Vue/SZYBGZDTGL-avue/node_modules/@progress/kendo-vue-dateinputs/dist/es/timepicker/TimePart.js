// @ts-ignore
import * as Vue from 'vue';
var allVue = Vue;
var gh = allVue.h;
var inject = allVue.inject;
import { cloneDate } from '@progress/kendo-date-math';
import { classNames, Keys } from '@progress/kendo-vue-common';
import { provideIntlService, provideLocalizationService } from '@progress/kendo-vue-intl';
import { messages, now, selectNow } from '../messages';
import { TimeList } from './TimeList';
import { MIDNIGHT_DATE, MIN_TIME, MAX_TIME } from '../utils';
import { TIME_PART } from './models/TimePart';
import { generateSnappers, getNow, isInTimeRange, snapTime, timeInRange } from './utils';
var formatRegExp = new RegExp(TIME_PART.hour + "|" + TIME_PART.minute + "|" + TIME_PART.second + "|" + TIME_PART.dayperiod + "|literal");
/**
 * @hidden
 */

export var Direction;

(function (Direction) {
  Direction[Direction["Left"] = 0] = "Left";
  Direction[Direction["Right"] = 1] = "Right";
})(Direction || (Direction = {}));

var TimePart = {
  name: 'KendoTimePart',
  props: {
    cancelButton: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: false
    },
    format: {
      type: String,
      default: function _default() {
        return 'hh:mm a';
      }
    },
    max: {
      type: Date,
      default: function _default() {
        return MAX_TIME;
      }
    },
    min: {
      type: Date,
      default: function _default() {
        return MIN_TIME;
      }
    },
    nowButton: {
      type: Boolean,
      default: true
    },
    steps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    smoothScroll: {
      type: Boolean,
      default: true
    },
    tabIndex: Number,
    value: {
      type: Date,
      default: function _default() {
        return null;
      }
    }
  },
  // @ts-ignore
  emits: {
    'change': null,
    'focus': null,
    'blur': null
  },
  created: function created() {
    this.timeLists = [];
    this.snapTime = snapTime(generateSnappers(this.$props.steps, this.$props.min));
    this.activeListIndex = -1;
    this.hasActiveButton = this.hasActiveButton.bind(this);
  },
  inject: {
    kendoIntlService: {
      default: null
    },
    kendoLocalizationService: {
      default: null
    }
  },
  data: function data() {
    return {
      activeListIndex: null
    };
  },
  computed: {
    element: function element() {
      return this._element;
    },
    computedValue: function computedValue() {
      return timeInRange(this.snapTime(cloneDate(this.$props.value || MIDNIGHT_DATE)), this.computedMin, this.computedMax);
    },
    intl: function intl() {
      return provideIntlService(this);
    },
    computedMin: function computedMin() {
      return this.snapTime(this.$props.min);
    },
    computedMax: function computedMax() {
      return this.snapTime(this.$props.max);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this._nowButton = this.$refs.nowButton;
    this.dateFormatParts.forEach(function (item, idx) {
      if (item.type !== 'literal') {
        _this.timeLists.push(_this.$refs['timeList' + idx]);
      }
    });
  },
  // @ts-ignore
  setup: !gh ? undefined : function () {
    var v3 = !!gh;
    var kendoIntlService = inject('kendoIntlService', {});
    var kendoLocalizationService = inject('kendoLocalizationService', {});
    return {
      v3: v3,
      kendoIntlService: kendoIntlService,
      kendoLocalizationService: kendoLocalizationService
    };
  },
  // @ts-ignore
  render: function render(createElement) {
    var h = gh || createElement;
    var _a = this.$props,
        format = _a.format,
        smoothScroll = _a.smoothScroll,
        disabled = _a.disabled;
    this.snapTime = snapTime(generateSnappers(this.$props.steps, this.computedMin));
    this.dateFormatParts = this.intl.splitDateFormat(format).filter(this.timeFormatFilter);
    var rootClassName = classNames({
      'k-state-disabled': disabled
    }, 'k-time-part');
    var localizationService = provideLocalizationService(this);
    var selectNowMessage = localizationService.toLanguageString(selectNow, messages[selectNow]);
    return h("div", {
      "class": rootClassName
    }, [h("div", {
      "class": "k-time-header"
    }, [h("span", {
      "class": "k-title"
    }, [this.intl.formatDate(this.computedValue, this.dateFormatParts.reduce(this.timeFormatReducer, ''))]), this.showNowButton() && h("button", {
      ref: 'nowButton',
      "class": "k-button k-flat k-time-now",
      title: selectNowMessage,
      attrs: this.v3 ? undefined : {
        title: selectNowMessage,
        "aria-label": selectNowMessage,
        tabIndex: disabled ? -1 : 0
      },
      "aria-label": selectNowMessage,
      onClick: this.onNowClick,
      on: this.v3 ? undefined : {
        "click": this.onNowClick
      },
      tabIndex: disabled ? -1 : 0
    }, [localizationService.toLanguageString(now, messages[now])])]), h("div", {
      "class": "k-time-list-container",
      onKeydown: this.handleKeyDown,
      on: this.v3 ? undefined : {
        "keydown": this.handleKeyDown
      }
    }, [h("span", {
      "class": "k-time-highlight"
    }), this.dateFormatParts.map(function (part, idx) {
      var _this = this;

      return part.type !== 'literal' ? h("div", {
        key: idx,
        "class": classNames('k-time-list-wrapper', {
          'k-state-focused': idx === this.activeListIndex
        }),
        role: "presentation",
        attrs: this.v3 ? undefined : {
          role: "presentation",
          tabIndex: -1
        },
        tabIndex: -1
      }, [h("span", {
        "class": "k-title",
        onMousedown: function onMousedown(e) {
          e.preventDefault();
        },
        on: this.v3 ? undefined : {
          "mousedown": function onMousedown(e) {
            e.preventDefault();
          }
        }
      }, [this.intl.dateFieldName(part)]), // @ts-ignore  function children
      h(TimeList, {
        min: this.computedMin,
        attrs: this.v3 ? undefined : {
          min: this.computedMin,
          max: this.computedMax,
          boundRange: this.$props.boundRange,
          part: part,
          step: part.type ? this.$props.steps[part.type] : 1,
          smoothScroll: smoothScroll,
          id: idx,
          value: this.computedValue,
          disabled: disabled
        },
        max: this.computedMax,
        boundRange: this.$props.boundRange,
        part: part,
        step: part.type ? this.$props.steps[part.type] : 1,
        smoothScroll: smoothScroll,
        ref: 'timeList' + idx,
        id: idx,
        onFocus: function onFocus(event) {
          _this.handleListFocus(event, idx);
        },
        on: this.v3 ? undefined : {
          "focus": function onFocus(event) {
            _this.handleListFocus(event, idx);
          },
          "blur": this.handleListBlur,
          "change": this.handleChange
        },
        onBlur: this.handleListBlur,
        onChange: this.handleChange,
        value: this.computedValue,
        disabled: disabled
      })]) : h("div", {
        key: idx,
        "class": "k-time-separator"
      }, [part.pattern]);
    }, this)])]);
  },
  methods: {
    onNowClick: function onNowClick(event) {
      this.$emit('nowclick', event);
    },
    focus: function focus(args) {
      var _this = this;

      this.$nextTick(function () {
        var timeList = _this.timeLists[0];

        if (!_this.hasActiveButton() && timeList && timeList.$el) {
          timeList.focus(args);
        }
      });
    },
    timeFormatReducer: function timeFormatReducer(acc, current) {
      return acc + current.pattern;
    },
    timeFormatFilter: function timeFormatFilter(part, index, all) {
      var prevItem = index >= 1 && all[index - 1];

      if (!prevItem) {
        return formatRegExp.test(part.type || '');
      }

      if (prevItem && part.type === 'literal') {
        return formatRegExp.test(prevItem.type || '');
      }

      return formatRegExp.test(part.type || '');
    },
    hasActiveButton: function hasActiveButton() {
      return document.activeElement === this._nowButton;
    },
    focusList: function focusList(dir) {
      if (!this.timeLists.length) {
        return;
      }

      this.timeLists.reduce(this.listReducer, []).map(function (state) {
        return dir === Direction.Right ? state.next : state.prev;
      }).map(function (list) {
        return list && list.$el && list.$el.focus({
          preventScroll: true
        });
      });
    },
    listReducer: function listReducer(state, list, idx, all) {
      if (state.length || list.$props.id !== this.activeListIndex) {
        return state;
      }

      return [{
        next: all[idx + 1] || list,
        prev: all[idx - 1] || list
      }];
    },
    showNowButton: function showNowButton() {
      return !this.hasSteps() && this.$props.nowButton && isInTimeRange(getNow(), this.computedMin, this.computedMax);
    },
    hasSteps: function hasSteps() {
      var _this = this;

      var keys = Object.keys(this.$props.steps);
      return keys.length !== keys.reduce(function (acc, k) {
        return acc + _this.$props.steps[k];
      }, 0);
    },
    handleKeyDown: function handleKeyDown(event) {
      var keyCode = event.keyCode;

      switch (keyCode) {
        case Keys.left:
          event.preventDefault();
          this.focusList(Direction.Left);
          return;

        case Keys.right:
          event.preventDefault();
          this.focusList(Direction.Right);
          return;

        default:
          return;
      }
    },
    handleListBlur: function handleListBlur(event) {
      this.$emit('blur', event);
    },
    handleListFocus: function handleListFocus(event, idx) {
      this.$emit('focus', event);
      this.activeListIndex = idx;
    },
    handleChange: function handleChange(candidate) {
      this.$emit('change', candidate);
    }
  }
};
export { TimePart };