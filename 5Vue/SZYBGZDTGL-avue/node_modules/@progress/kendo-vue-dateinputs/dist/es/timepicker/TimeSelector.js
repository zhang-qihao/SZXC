// @ts-ignore
import * as Vue from 'vue';
var allVue = Vue;
var gh = allVue.h;
var inject = allVue.inject;
import { cloneDate } from '@progress/kendo-date-math';
import { classNames, Keys } from '@progress/kendo-vue-common';
import { provideIntlService, provideLocalizationService } from '@progress/kendo-vue-intl';
import { messages, timePickerCancel, timePickerSet } from '../messages';
import { MIN_TIME, MAX_TIME, MIDNIGHT_DATE } from '../utils';
import { generateGetters, getNow, valueMerger } from './utils';
import { TimePart } from './TimePart';
/**
 * @hidden
 */

export var Direction;

(function (Direction) {
  Direction[Direction["Left"] = 0] = "Left";
  Direction[Direction["Right"] = 1] = "Right";
})(Direction || (Direction = {}));

var TimeSelector = {
  name: 'KendoTimeSelector',
  // @ts-ignore
  emits: {
    'change': null,
    'focus': null,
    'blur': null
  },
  props: {
    cancelButton: {
      type: Boolean,
      default: true
    },
    boundRange: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    format: {
      type: String,
      default: function _default() {
        return 't';
      }
    },
    max: {
      type: Date,
      default: function _default() {
        return MAX_TIME;
      }
    },
    min: {
      type: Date,
      default: function _default() {
        return MIN_TIME;
      }
    },
    nowButton: Boolean,
    steps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    smoothScroll: {
      type: Boolean,
      default: true
    },
    tabIndex: Number,
    value: {
      type: Date,
      default: function _default() {
        return null;
      }
    }
  },
  created: function created() {
    this.dateFormatParts = this.intl.splitDateFormat(this.$props.format);
    this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));
    this.hasActiveButton = this.hasActiveButton.bind(this);
    this.currentState = this.$props.value || MIDNIGHT_DATE;
    this.currentValue = this.$props.value;
  },
  inject: {
    kendoIntlService: {
      default: null
    },
    kendoLocalizationService: {
      default: null
    }
  },
  data: function data() {
    return {
      currentState: null,
      currentValue: null,
      valueDuringOnChange: undefined
    };
  },
  computed: {
    computedValue: function computedValue() {
      var value = this.valueDuringOnChange !== undefined ? this.valueDuringOnChange : this.$props.value !== null ? this.$props.value : this.currentValue;
      return value !== null ? cloneDate(value) : null;
    },
    intl: function intl() {
      return provideIntlService(this);
    },
    current: function current() {
      return this.currentState !== null ? cloneDate(this.currentState) : null;
    }
  },
  mounted: function mounted() {
    this.timePart = this.$refs.timePart;
    this._acceptButton = this.$refs.acceptButton;
    this._cancelButton = this.$refs.cancelButton;
  },
  // @ts-ignore
  setup: !gh ? undefined : function () {
    var v3 = !!gh;
    var kendoIntlService = inject('kendoIntlService', {});
    var kendoLocalizationService = inject('kendoLocalizationService', {});
    return {
      v3: v3,
      kendoIntlService: kendoIntlService,
      kendoLocalizationService: kendoLocalizationService
    };
  },
  // @ts-ignore
  render: function render(createElement) {
    var h = gh || createElement;
    var _a = this.$props,
        format = _a.format,
        cancelButton = _a.cancelButton,
        disabled = _a.disabled,
        tabIndex = _a.tabIndex,
        smoothScroll = _a.smoothScroll,
        min = _a.min,
        max = _a.max,
        boundRange = _a.boundRange,
        nowButton = _a.nowButton,
        steps = _a.steps;
    var localizationService = provideLocalizationService(this);
    var cancelMessage = localizationService.toLanguageString(timePickerCancel, messages[timePickerCancel]);
    var setMessage = localizationService.toLanguageString(timePickerSet, messages[timePickerSet]);
    return h("div", {
      tabIndex: !disabled ? tabIndex || 0 : undefined,
      attrs: this.v3 ? undefined : {
        tabIndex: !disabled ? tabIndex || 0 : undefined
      },
      "class": classNames('k-timeselector k-reset', {
        'k-state-disabled': disabled
      }),
      onKeydown: this.handleKeyDown,
      on: this.v3 ? undefined : {
        "keydown": this.handleKeyDown
      }
    }, [// @ts-ignore  function children
    h(TimePart, {
      ref: 'timePart',
      value: this.current,
      attrs: this.v3 ? undefined : {
        value: this.current,
        format: format,
        smoothScroll: smoothScroll,
        min: min,
        max: max,
        boundRange: boundRange,
        disabled: disabled,
        nowButton: nowButton,
        steps: steps
      },
      onChange: this.handleChange,
      on: this.v3 ? undefined : {
        "change": this.handleChange,
        "nowclick": this.handleNowClick,
        "focus": this.handleFocus,
        "blur": this.handleBlur
      },
      onNowclick: this.handleNowClick,
      format: format,
      smoothScroll: smoothScroll,
      min: min,
      max: max,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur,
      boundRange: boundRange,
      disabled: disabled,
      nowButton: nowButton,
      steps: steps
    }), h("div", {
      "class": "k-time-footer k-action-buttons"
    }, [cancelButton && h("button", {
      ref: 'cancelButton',
      "class": "k-button k-time-cancel",
      onClick: this.handleReject,
      on: this.v3 ? undefined : {
        "click": this.handleReject
      },
      title: cancelMessage,
      attrs: this.v3 ? undefined : {
        title: cancelMessage,
        "aria-label": cancelMessage
      },
      "aria-label": cancelMessage
    }, [cancelMessage]), h("button", {
      ref: 'acceptButton',
      "class": "k-time-accept k-button k-primary",
      onClick: this.handleAccept,
      on: this.v3 ? undefined : {
        "click": this.handleAccept
      },
      title: setMessage,
      attrs: this.v3 ? undefined : {
        title: setMessage,
        "aria-label": setMessage
      },
      "aria-label": setMessage
    }, [setMessage])])]);
  },
  methods: {
    handleBlur: function handleBlur(event) {
      this.$emit('blur', event);
    },
    handleFocus: function handleFocus(event) {
      this.$emit('focus', event);
    },
    focusActiveList: function focusActiveList() {
      if (!this.timePart) {
        return;
      }

      this.timePart.focus({
        preventScroll: true
      });
    },
    hasActiveButton: function hasActiveButton() {
      if (!this._acceptButton) {
        return false;
      }

      return document.activeElement === this._acceptButton || document.activeElement === this._cancelButton;
    },
    handleKeyDown: function handleKeyDown(event) {
      var keyCode = event.keyCode;
      this.$emit('keydown', event);

      switch (keyCode) {
        case Keys.enter:
          if (!this.hasActiveButton()) {
            this.handleAccept(event);
          }

          return;

        default:
          return;
      }
    },
    handleAccept: function handleAccept(event) {
      var value = this.mergeValue(cloneDate(this.computedValue || getNow()), this.timePart ? this.timePart.value : this.current);
      this.currentValue = value;
      this.valueDuringOnChange = value;
      this.$emit('change', {
        event: event,
        value: this.computedValue,
        target: this
      });
      this.valueDuringOnChange = undefined;
    },
    handleReject: function handleReject(event) {
      this.currentState = this.computedValue;
      this.$emit('reject', event);
    },
    handleNowClick: function handleNowClick(event) {
      var now = this.mergeValue(cloneDate(this.computedValue || getNow()), getNow());
      this.currentState = now;
      this.currentValue = now;
      this.valueDuringOnChange = now;
      this.$emit('change', {
        event: event,
        value: this.computedValue,
        target: this
      });
      this.valueDuringOnChange = undefined;
    },
    handleChange: function handleChange(candidate) {
      this.currentState = candidate;
    }
  }
};
export { TimeSelector };