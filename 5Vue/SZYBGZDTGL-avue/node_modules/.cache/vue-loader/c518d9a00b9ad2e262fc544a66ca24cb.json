{"remainingRequest":"C:\\Users\\10415\\Desktop\\0工程\\5Vue\\SZYBGZDTGL-avue\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\10415\\Desktop\\0工程\\5Vue\\SZYBGZDTGL-avue\\node_modules\\vue-codemirror\\src\\codemirror.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Users\\10415\\Desktop\\0工程\\5Vue\\SZYBGZDTGL-avue\\node_modules\\vue-codemirror\\src\\codemirror.vue","mtime":499162500000},{"path":"C:\\Users\\10415\\Desktop\\0工程\\5Vue\\SZYBGZDTGL-avue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\10415\\Desktop\\0工程\\5Vue\\SZYBGZDTGL-avue\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"C:\\Users\\10415\\Desktop\\0工程\\5Vue\\SZYBGZDTGL-avue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\10415\\Desktop\\0工程\\5Vue\\SZYBGZDTGL-avue\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n\n// lib\nimport _CodeMirror from 'codemirror'\nconst CodeMirror = window.CodeMirror || _CodeMirror\n\n// pollfill\nif (typeof Object.assign != 'function') {\n  Object.defineProperty(Object, 'assign', {\n    value(target, varArgs) {\n      if (target == null) {\n        throw new TypeError('Cannot convert undefined or null to object')\n      }\n      const to = Object(target)\n      for (let index = 1; index < arguments.length; index++) {\n        const nextSource = arguments[index]\n        if (nextSource != null) {\n          for (const nextKey in nextSource) {\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey]\n            }\n          }\n        }\n      }\n      return to\n    },\n    writable: true,\n    configurable: true\n  })\n}\n\n// export\nexport default {\n  name: 'codemirror',\n  data() {\n    return {\n      content: '',\n      codemirror: null,\n      cminstance: null\n    }\n  },\n  props: {\n    code: String,\n    value: String,\n    marker: Function,\n    unseenLines: Array,\n    name: {\n      type: String,\n      default: 'codemirror'\n    },\n    placeholder: {\n      type: String,\n      default: ''\n    },\n    merge: {\n      type: Boolean,\n      default: false\n    },\n    options: {\n      type: Object,\n      default: () => ({})\n    },\n    events: {\n      type: Array,\n      default: () => ([])\n    },\n    globalOptions: {\n      type: Object,\n      default: () => ({})\n    },\n    globalEvents: {\n      type: Array,\n      default: () => ([])\n    }\n  },\n  watch: {\n    options: {\n      deep: true,\n      handler(options) {\n        for (const key in options) {\n          this.cminstance.setOption(key, options[key])\n        }\n      }\n    },\n    merge() {\n      this.$nextTick(this.switchMerge)\n    },\n    code(newVal) {\n      this.handerCodeChange(newVal)\n    },\n    value(newVal) {\n      this.handerCodeChange(newVal)\n    },\n  },\n  methods: {\n    initialize() {\n      const cmOptions = Object.assign({}, this.globalOptions, this.options)\n      if (this.merge) {\n        this.codemirror = CodeMirror.MergeView(this.$refs.mergeview, cmOptions)\n        this.cminstance = this.codemirror.edit\n      } else {\n        this.codemirror = CodeMirror.fromTextArea(this.$refs.textarea, cmOptions)\n        this.cminstance = this.codemirror\n        this.cminstance.setValue(this.code || this.value || this.content)\n      }\n      this.cminstance.on('change', cm => {\n        this.content = cm.getValue()\n        if (this.$emit) {\n          this.$emit('input', this.content)\n        }\n      })\n\n      // 所有有效事件（驼峰命名）+ 去重\n      const tmpEvents = {}\n      const allEvents = [\n        'scroll',\n        'changes',\n        'beforeChange',\n        'cursorActivity',\n        'keyHandled',\n        'inputRead',\n        'electricInput',\n        'beforeSelectionChange',\n        'viewportChange',\n        'swapDoc',\n        'gutterClick',\n        'gutterContextMenu',\n        'focus',\n        'blur',\n        'refresh',\n        'optionChange',\n        'scrollCursorIntoView',\n        'update'\n      ]\n      .concat(this.events)\n      .concat(this.globalEvents)\n      .filter(e => (!tmpEvents[e] && (tmpEvents[e] = true)))\n      .forEach(event => {\n        // 循环事件，并兼容 run-time 事件命名\n        this.cminstance.on(event, (...args) => {\n          // console.log('当有事件触发了', event, args)\n          this.$emit(event, ...args)\n          const lowerCaseEvent = event.replace(/([A-Z])/g, '-$1').toLowerCase()\n          if (lowerCaseEvent !== event) {\n            this.$emit(lowerCaseEvent, ...args)\n          }\n        })\n      })\n\n      this.$emit('ready', this.codemirror)\n      this.unseenLineMarkers()\n\n      // prevents funky dynamic rendering\n      this.refresh()\n    },\n    refresh() {\n      this.$nextTick(() => {\n        this.cminstance.refresh()\n      })\n    },\n    destroy() {\n      // garbage cleanup\n      const element = this.cminstance.doc.cm.getWrapperElement()\n      element && element.remove && element.remove()\n    },\n    handerCodeChange(newVal) {\n      const cm_value = this.cminstance.getValue()\n      if (newVal !== cm_value) {\n        const scrollInfo = this.cminstance.getScrollInfo()\n        this.cminstance.setValue(newVal)\n        this.content = newVal\n        this.cminstance.scrollTo(scrollInfo.left, scrollInfo.top)\n      }\n      this.unseenLineMarkers()\n    },\n    unseenLineMarkers() {\n      if (this.unseenLines !== undefined && this.marker !== undefined) {\n        this.unseenLines.forEach(line => {\n          const info = this.cminstance.lineInfo(line)\n          this.cminstance.setGutterMarker(line, 'breakpoints', info.gutterMarkers ? null : this.marker())\n        })\n      }\n    },\n    switchMerge() {\n      // Save current values\n      const history = this.cminstance.doc.history\n      const cleanGeneration = this.cminstance.doc.cleanGeneration\n      this.options.value = this.cminstance.getValue()\n\n      this.destroy()\n      this.initialize()\n\n      // Restore values\n      this.cminstance.doc.history = history\n      this.cminstance.doc.cleanGeneration = cleanGeneration\n    }\n  },\n  mounted() {\n    this.initialize()\n  },\n  beforeDestroy() {\n    this.destroy()\n  }\n}\n",{"version":3,"sources":["codemirror.vue"],"names":[],"mappings":";;;;;;;;AAQA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"codemirror.vue","sourceRoot":"node_modules/vue-codemirror/src","sourcesContent":["<template>\n  <div class=\"vue-codemirror\" :class=\"{ merge }\">\n    <div ref=\"mergeview\" v-if=\"merge\"></div>\n    <textarea ref=\"textarea\" :name=\"name\" :placeholder=\"placeholder\" v-else></textarea>\n  </div>\n</template>\n\n<script>\n  // lib\n  import _CodeMirror from 'codemirror'\n  const CodeMirror = window.CodeMirror || _CodeMirror\n\n  // pollfill\n  if (typeof Object.assign != 'function') {\n    Object.defineProperty(Object, 'assign', {\n      value(target, varArgs) {\n        if (target == null) {\n          throw new TypeError('Cannot convert undefined or null to object')\n        }\n        const to = Object(target)\n        for (let index = 1; index < arguments.length; index++) {\n          const nextSource = arguments[index]\n          if (nextSource != null) {\n            for (const nextKey in nextSource) {\n              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                to[nextKey] = nextSource[nextKey]\n              }\n            }\n          }\n        }\n        return to\n      },\n      writable: true,\n      configurable: true\n    })\n  }\n\n  // export\n  export default {\n    name: 'codemirror',\n    data() {\n      return {\n        content: '',\n        codemirror: null,\n        cminstance: null\n      }\n    },\n    props: {\n      code: String,\n      value: String,\n      marker: Function,\n      unseenLines: Array,\n      name: {\n        type: String,\n        default: 'codemirror'\n      },\n      placeholder: {\n        type: String,\n        default: ''\n      },\n      merge: {\n        type: Boolean,\n        default: false\n      },\n      options: {\n        type: Object,\n        default: () => ({})\n      },\n      events: {\n        type: Array,\n        default: () => ([])\n      },\n      globalOptions: {\n        type: Object,\n        default: () => ({})\n      },\n      globalEvents: {\n        type: Array,\n        default: () => ([])\n      }\n    },\n    watch: {\n      options: {\n        deep: true,\n        handler(options) {\n          for (const key in options) {\n            this.cminstance.setOption(key, options[key])\n          }\n        }\n      },\n      merge() {\n        this.$nextTick(this.switchMerge)\n      },\n      code(newVal) {\n        this.handerCodeChange(newVal)\n      },\n      value(newVal) {\n        this.handerCodeChange(newVal)\n      },\n    },\n    methods: {\n      initialize() {\n        const cmOptions = Object.assign({}, this.globalOptions, this.options)\n        if (this.merge) {\n          this.codemirror = CodeMirror.MergeView(this.$refs.mergeview, cmOptions)\n          this.cminstance = this.codemirror.edit\n        } else {\n          this.codemirror = CodeMirror.fromTextArea(this.$refs.textarea, cmOptions)\n          this.cminstance = this.codemirror\n          this.cminstance.setValue(this.code || this.value || this.content)\n        }\n        this.cminstance.on('change', cm => {\n          this.content = cm.getValue()\n          if (this.$emit) {\n            this.$emit('input', this.content)\n          }\n        })\n\n        // 所有有效事件（驼峰命名）+ 去重\n        const tmpEvents = {}\n        const allEvents = [\n          'scroll',\n          'changes',\n          'beforeChange',\n          'cursorActivity',\n          'keyHandled',\n          'inputRead',\n          'electricInput',\n          'beforeSelectionChange',\n          'viewportChange',\n          'swapDoc',\n          'gutterClick',\n          'gutterContextMenu',\n          'focus',\n          'blur',\n          'refresh',\n          'optionChange',\n          'scrollCursorIntoView',\n          'update'\n        ]\n        .concat(this.events)\n        .concat(this.globalEvents)\n        .filter(e => (!tmpEvents[e] && (tmpEvents[e] = true)))\n        .forEach(event => {\n          // 循环事件，并兼容 run-time 事件命名\n          this.cminstance.on(event, (...args) => {\n            // console.log('当有事件触发了', event, args)\n            this.$emit(event, ...args)\n            const lowerCaseEvent = event.replace(/([A-Z])/g, '-$1').toLowerCase()\n            if (lowerCaseEvent !== event) {\n              this.$emit(lowerCaseEvent, ...args)\n            }\n          })\n        })\n\n        this.$emit('ready', this.codemirror)\n        this.unseenLineMarkers()\n\n        // prevents funky dynamic rendering\n        this.refresh()\n      },\n      refresh() {\n        this.$nextTick(() => {\n          this.cminstance.refresh()\n        })\n      },\n      destroy() {\n        // garbage cleanup\n        const element = this.cminstance.doc.cm.getWrapperElement()\n        element && element.remove && element.remove()\n      },\n      handerCodeChange(newVal) {\n        const cm_value = this.cminstance.getValue()\n        if (newVal !== cm_value) {\n          const scrollInfo = this.cminstance.getScrollInfo()\n          this.cminstance.setValue(newVal)\n          this.content = newVal\n          this.cminstance.scrollTo(scrollInfo.left, scrollInfo.top)\n        }\n        this.unseenLineMarkers()\n      },\n      unseenLineMarkers() {\n        if (this.unseenLines !== undefined && this.marker !== undefined) {\n          this.unseenLines.forEach(line => {\n            const info = this.cminstance.lineInfo(line)\n            this.cminstance.setGutterMarker(line, 'breakpoints', info.gutterMarkers ? null : this.marker())\n          })\n        }\n      },\n      switchMerge() {\n        // Save current values\n        const history = this.cminstance.doc.history\n        const cleanGeneration = this.cminstance.doc.cleanGeneration\n        this.options.value = this.cminstance.getValue()\n\n        this.destroy()\n        this.initialize()\n\n        // Restore values\n        this.cminstance.doc.history = history\n        this.cminstance.doc.cleanGeneration = cleanGeneration\n      }\n    },\n    mounted() {\n      this.initialize()\n    },\n    beforeDestroy() {\n      this.destroy()\n    }\n  }\n</script>\n"]}]}